============================= test session starts ==============================
platform linux -- Python 3.9.18, pytest-7.1.3, pluggy-1.5.0 -- /home/nikita/python-yandex_p/django_sprint3/venv/bin/python3.9
django: settings: blogicum.settings (from ini)
rootdir: /home/nikita/python-yandex_p/django_sprint3, configfile: pytest.ini, testpaths: tests/
plugins: django-4.5.2, Faker-12.0.1
collecting ... collected 82 items

tests/test_category_page_views.py::test_category_page ERROR              [  1%]
tests/test_category_page_views.py::test_category_page_check_context_keys[title] ERROR [  2%]
tests/test_category_page_views.py::test_category_page_check_context_keys[key1] ERROR [  3%]
tests/test_category_page_views.py::test_category_page_check_context_keys[key2] ERROR [  4%]
tests/test_category_page_views.py::test_category_page_check_context_keys[key3] ERROR [  6%]
tests/test_category_page_views.py::test_category_page_category_unpublished ERROR [  7%]
tests/test_category_page_views.py::test_category_page_posts_unpublished ERROR [  8%]
tests/test_category_page_views.py::test_category_page_pub_date_later_today ERROR [  9%]
tests/test_category_page_views.py::test_category_page_posts_with_location ERROR [ 10%]
tests/test_category_page_views.py::test_category_page_posts_with_unpublished_locations ERROR [ 12%]
tests/test_category_page_views.py::test_many_posts_on_category_page ERROR [ 13%]
tests/test_category_page_views.py::test_no_other_posts_on_category_page ERROR [ 14%]
tests/test_pageapp_views.py::test_pageapp_views[about] PASSED            [ 15%]
tests/test_pageapp_views.py::test_pageapp_views[rules] PASSED            [ 17%]
tests/test_post_detail_views.py::test_posts_page_pk_published_location PASSED [ 18%]
tests/test_post_detail_views.py::test_posts_page_pk_unpublished_location PASSED [ 19%]
tests/test_post_detail_views.py::test_posts_page_pk_post_doesnt_exists PASSED [ 20%]
tests/test_post_detail_views.py::test_posts_page_pk_check_context_keys[title] PASSED [ 21%]
tests/test_post_detail_views.py::test_posts_page_pk_check_context_keys[text] PASSED [ 23%]
tests/test_post_detail_views.py::test_posts_page_pk_check_context_keys[key2] PASSED [ 24%]
tests/test_post_detail_views.py::test_posts_page_pk_check_context_keys[key3] PASSED [ 25%]
tests/test_post_detail_views.py::test_posts_page_pk_check_context_keys[key4] PASSED [ 26%]
tests/test_post_detail_views.py::test_posts_page_pk_unpublished_post PASSED [ 28%]
tests/test_post_detail_views.py::test_posts_page_pk_pub_date_later_today PASSED [ 29%]
tests/test_post_detail_views.py::test_posts_page_pk_category_unpublished PASSED [ 30%]
tests/test_post_detail_views.py::test_posts_page_pk_post_with_published_location_and_category PASSED [ 31%]
tests/test_post_model.py::TestPostModelAttrs::test_model_attrs[title-CharField-params0] <- tests/conftest.py PASSED [ 32%]
tests/test_post_model.py::TestPostModelAttrs::test_model_attrs[text-TextField-params1] <- tests/conftest.py PASSED [ 34%]
tests/test_post_model.py::TestPostModelAttrs::test_model_attrs[pub_date-DateTimeField-params2] <- tests/conftest.py PASSED [ 35%]
tests/test_post_model.py::TestPostModelAttrs::test_model_attrs[author-ForeignKey-params3] <- tests/conftest.py PASSED [ 36%]
tests/test_post_model.py::TestPostModelAttrs::test_model_attrs[location-ForeignKey-params4] <- tests/conftest.py PASSED [ 37%]
tests/test_post_model.py::TestPostModelAttrs::test_model_attrs[category-ForeignKey-params5] <- tests/conftest.py PASSED [ 39%]
tests/test_post_model.py::TestPostModelAttrs::test_model_attrs[is_published-BooleanField-params6] <- tests/conftest.py PASSED [ 40%]
tests/test_post_model.py::TestPostModelAttrs::test_model_attrs[created_at-DateTimeField-params7] <- tests/conftest.py PASSED [ 41%]
tests/test_post_model.py::test_author_on_delete PASSED                   [ 42%]
tests/test_post_model.py::test_location_on_delete PASSED                 [ 43%]
tests/test_posts_page_views.py::test_all_unpublished PASSED              [ 45%]
tests/test_posts_page_views.py::test_mixed_published PASSED              [ 46%]
tests/test_posts_page_views.py::test_check_context_keys[title] PASSED    [ 47%]
tests/test_posts_page_views.py::test_check_context_keys[key1] PASSED     [ 48%]
tests/test_posts_page_views.py::test_check_context_keys[key2] PASSED     [ 50%]
tests/test_posts_page_views.py::test_check_context_keys[key3] PASSED     [ 51%]
tests/test_posts_page_views.py::test_category_unpublished PASSED         [ 52%]
tests/test_posts_page_views.py::test_pub_date_later_today PASSED         [ 53%]
tests/test_posts_page_views.py::test_posts_with_published_location PASSED [ 54%]
tests/test_posts_page_views.py::test_posts_with_unpublished_locations PASSED [ 56%]
tests/test_posts_page_views.py::test_many_posts_on_main_page PASSED      [ 57%]
tests/test_admin_page.py::test_admin_register PASSED                     [ 58%]
tests/test_category_model.py::TestCategoryModelAttrs::test_model_attrs[title-CharField-params0] <- tests/conftest.py PASSED [ 59%]
tests/test_category_model.py::TestCategoryModelAttrs::test_model_attrs[description-TextField-params1] <- tests/conftest.py PASSED [ 60%]
tests/test_category_model.py::TestCategoryModelAttrs::test_model_attrs[slug-SlugField-params2] <- tests/conftest.py PASSED [ 62%]
tests/test_category_model.py::TestCategoryModelAttrs::test_model_attrs[is_published-BooleanField-params3] <- tests/conftest.py PASSED [ 63%]
tests/test_category_model.py::TestCategoryModelAttrs::test_model_attrs[created_at-DateTimeField-params4] <- tests/conftest.py PASSED [ 64%]
tests/test_localization.py::test_rus_localization PASSED                 [ 65%]
tests/test_localization.py::test_blog_in_rus PASSED                      [ 67%]
tests/test_localization.py::test_models_translated[Category-\u043a\u0430\u0442\u0435\u0433\u043e\u0440\u0438\u044f-\u041a\u0430\u0442\u0435\u0433\u043e\u0440\u0438\u0438] PASSED [ 68%]
tests/test_localization.py::test_models_translated[Location-\u043c\u0435\u0441\u0442\u043e\u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u0435-\u041c\u0435\u0441\u0442\u043e\u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u044f] PASSED [ 69%]
tests/test_localization.py::test_models_translated[Post-\u043f\u0443\u0431\u043b\u0438\u043a\u0430\u0446\u0438\u044f-\u041f\u0443\u0431\u043b\u0438\u043a\u0430\u0446\u0438\u0438] PASSED [ 70%]
tests/test_localization.py::test_models_params_translate[Category-is_published-\u041e\u043f\u0443\u0431\u043b\u0438\u043a\u043e\u0432\u0430\u043d\u043e] PASSED [ 71%]
tests/test_localization.py::test_models_params_translate[Category-title-\u0417\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a] PASSED [ 73%]
tests/test_localization.py::test_models_params_translate[Category-slug-\u0418\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440] PASSED [ 74%]
tests/test_localization.py::test_models_params_translate[Category-description-\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435] PASSED [ 75%]
tests/test_localization.py::test_models_params_translate[Category-created_at-\u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u043e] PASSED [ 76%]
tests/test_localization.py::test_models_params_translate[Location-name-\u041d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u043c\u0435\u0441\u0442\u0430] PASSED [ 78%]
tests/test_localization.py::test_models_params_translate[Location-created_at-\u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u043e] PASSED [ 79%]
tests/test_localization.py::test_models_params_translate[Location-is_published-\u041e\u043f\u0443\u0431\u043b\u0438\u043a\u043e\u0432\u0430\u043d\u043e] PASSED [ 80%]
tests/test_localization.py::test_models_params_translate[Post-pub_date-\u0414\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043c\u044f \u043f\u0443\u0431\u043b\u0438\u043a\u0430\u0446\u0438\u0438] PASSED [ 81%]
tests/test_localization.py::test_models_params_translate[Post-text-\u0422\u0435\u043a\u0441\u0442] PASSED [ 82%]
tests/test_localization.py::test_models_params_translate[Post-author-\u0410\u0432\u0442\u043e\u0440 \u043f\u0443\u0431\u043b\u0438\u043a\u0430\u0446\u0438\u0438] PASSED [ 84%]
tests/test_localization.py::test_models_params_translate[Post-category-\u041a\u0430\u0442\u0435\u0433\u043e\u0440\u0438\u044f] PASSED [ 85%]
tests/test_localization.py::test_models_params_translate[Post-location-\u041c\u0435\u0441\u0442\u043e\u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u0435] PASSED [ 86%]
tests/test_localization.py::test_models_params_translate[Post-created_at-\u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u043e] PASSED [ 87%]
tests/test_localization.py::test_models_params_translate[Post-is_published-\u041e\u043f\u0443\u0431\u043b\u0438\u043a\u043e\u0432\u0430\u043d\u043e] PASSED [ 89%]
tests/test_localization.py::test_help_text_translate[Category-is_published-\u0421\u043d\u0438\u043c\u0438\u0442\u0435 \u0433\u0430\u043b\u043e\u0447\u043a\u0443, \u0447\u0442\u043e\u0431\u044b \u0441\u043a\u0440\u044b\u0442\u044c \u043f\u0443\u0431\u043b\u0438\u043a\u0430\u0446\u0438\u044e.] PASSED [ 90%]
tests/test_localization.py::test_help_text_translate[Category-slug-\u0418\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b \u0434\u043b\u044f URL; \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d\u044b \u0441\u0438\u043c\u0432\u043e\u043b\u044b \u043b\u0430\u0442\u0438\u043d\u0438\u0446\u044b, \u0446\u0438\u0444\u0440\u044b, \u0434\u0435\u0444\u0438\u0441 \u0438 \u043f\u043e\u0434\u0447\u0451\u0440\u043a\u0438\u0432\u0430\u043d\u0438\u0435.] PASSED [ 91%]
tests/test_localization.py::test_help_text_translate[Post-pub_date-\u0415\u0441\u043b\u0438 \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c \u0434\u0430\u0442\u0443 \u0438 \u0432\u0440\u0435\u043c\u044f \u0432 \u0431\u0443\u0434\u0443\u0449\u0435\u043c \u2014 \u043c\u043e\u0436\u043d\u043e \u0434\u0435\u043b\u0430\u0442\u044c \u043e\u0442\u043b\u043e\u0436\u0435\u043d\u043d\u044b\u0435 \u043f\u0443\u0431\u043b\u0438\u043a\u0430\u0446\u0438\u0438.] PASSED [ 92%]
tests/test_location_model.py::TestLocationModelAttrs::test_model_attrs[name-CharField-params0] <- tests/conftest.py PASSED [ 93%]
tests/test_location_model.py::TestLocationModelAttrs::test_model_attrs[is_published-BooleanField-params1] <- tests/conftest.py PASSED [ 95%]
tests/test_location_model.py::TestLocationModelAttrs::test_model_attrs[created_at-DateTimeField-params2] <- tests/conftest.py PASSED [ 96%]
tests/test_urls.py::test_blog_urls PASSED                                [ 97%]
tests/test_urls.py::test_pages_urls PASSED                               [ 98%]
tests/test_urls.py::test_blogicum_urls PASSED                            [100%]

==================================== ERRORS ====================================
_____________________ ERROR at setup of test_category_page _____________________

user_client = <django.test.client.Client object at 0x7fc4c1a3b3a0>
page_url = '/category/mission-high/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests/conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c1a3b3a0>
path = '/category/mission-high/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv/lib/python3.9/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c1a3b3a0>
path = '/category/mission-high/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv/lib/python3.9/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c1a3b3a0>, method = 'GET'
path = '/category/mission-high/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/mission-high/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/mission-high/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv/lib/python3.9/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c1a3b3a0>
request = {'PATH_INFO': '/category/mission-high/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=m55inwj5t3wsd4ratj5w4qe1iol0qebd', 'PATH_INFO': '/category/mission-high/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'is_email': False, 'unicode_hint': '', 'frames': [{'exc_c...jango.template.base.Template object at 0x7fc4c18272e0>, <django.template.base.Template object at 0x7fc4c18272e0>, ...]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7fc4c22fbe50>, {'templates': [<django.template.base.Template...irst': False, 'last': True}, 'panel': <debug_toolbar.panels.profiling.ProfilingPanel object at 0x7fc4c182c7c0>}, {}]]})
signal_uid = 'template-render-140483038424448'
exception_uid = 'request-exception-140483038424448'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv/lib/python3.9/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c1a3b3a0>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv/lib/python3.9/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/mission-high/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7fc4c1a3b1f0>
request = <WSGIRequest: GET '/category/mission-high/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv/lib/python3.9/site-packages/django/core/handlers/base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/mission-high/'>
category_slug = 'mission-high'

    def category_posts(request, category_slug):
        """View функция для страницы категорий."""
        try:
            category = Category.objects.get(slug=category_slug, is_published=True)
        except Category.DoesNotExist:
            raise Http404(f"Категория '{category_slug}' не найдена")
>       post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')

blogicum/blog/views.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.manager.Manager object at 0x7fc4c1838e50>, args = ()
kwargs = {'category': <Category: Place Modern Per Edge Successful Side>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def manager_method(self, *args, **kwargs):
>       return getattr(self.get_queryset(), name)(*args, **kwargs)

venv/lib/python3.9/site-packages/django/db/models/manager.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
args = ()
kwargs = {'category': <Category: Place Modern Per Edge Successful Side>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def filter(self, *args, **kwargs):
        """
        Return a new QuerySet instance with the args ANDed to the existing
        set.
        """
        self._not_support_combined_queries('filter')
>       return self._filter_or_exclude(False, args, kwargs)

venv/lib/python3.9/site-packages/django/db/models/query.py:941: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
negate = False, args = ()
kwargs = {'category': <Category: Place Modern Per Edge Successful Side>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def _filter_or_exclude(self, negate, args, kwargs):
        if args or kwargs:
            assert not self.query.is_sliced, \
                "Cannot filter a query once a slice has been taken."
    
        clone = self._chain()
        if self._defer_next_filter:
            self._defer_next_filter = False
            clone._deferred_filter = negate, args, kwargs
        else:
>           clone._filter_or_exclude_inplace(negate, args, kwargs)

venv/lib/python3.9/site-packages/django/db/models/query.py:961: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
negate = False, args = ()
kwargs = {'category': <Category: Place Modern Per Edge Successful Side>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def _filter_or_exclude_inplace(self, negate, args, kwargs):
        if negate:
            self._query.add_q(~Q(*args, **kwargs))
        else:
>           self._query.add_q(Q(*args, **kwargs))

venv/lib/python3.9/site-packages/django/db/models/query.py:968: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c1838940>
q_object = <Q: (AND: ('category', <Category: Place Modern Per Edge Successful Side>), ('is_published', True), ('pub_date__lt', <function now at 0x7fc4c29e8d30>))>

    def add_q(self, q_object):
        """
        A preprocessor for the internal _add_q(). Responsible for doing final
        join promotion.
        """
        # For join promotion this case is doing an AND for the added q_object
        # and existing conditions. So, any existing inner join forces the join
        # type to remain inner. Existing outer joins can however be demoted.
        # (Consider case where rel_a is LOUTER and rel_a__col=1 is added - if
        # rel_a doesn't produce any rows, then the whole condition must fail.
        # So, demotion is OK.
        existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
>       clause, _ = self._add_q(q_object, self.used_aliases)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c1838940>
q_object = <Q: (AND: ('category', <Category: Place Modern Per Edge Successful Side>), ('is_published', True), ('pub_date__lt', <function now at 0x7fc4c29e8d30>))>
used_aliases = {'blog_post'}, branch_negated = False, current_negated = False
allow_joins = True, split_subq = True, check_filterable = True

    def _add_q(self, q_object, used_aliases, branch_negated=False,
               current_negated=False, allow_joins=True, split_subq=True,
               check_filterable=True):
        """Add a Q-object to the current filter."""
        connector = q_object.connector
        current_negated = current_negated ^ q_object.negated
        branch_negated = branch_negated or q_object.negated
        target_clause = self.where_class(connector=connector,
                                         negated=q_object.negated)
        joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
        for child in q_object.children:
>           child_clause, needed_inner = self.build_filter(
                child, can_reuse=used_aliases, branch_negated=branch_negated,
                current_negated=current_negated, allow_joins=allow_joins,
                split_subq=split_subq, check_filterable=check_filterable,
            )

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1435: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c1838940>
filter_expr = ('pub_date__lt', <function now at 0x7fc4c29e8d30>)
branch_negated = False, current_negated = False, can_reuse = {'blog_post'}
allow_joins = True, split_subq = True, reuse_with_filtered_relation = False
check_filterable = True

    def build_filter(self, filter_expr, branch_negated=False, current_negated=False,
                     can_reuse=None, allow_joins=True, split_subq=True,
                     reuse_with_filtered_relation=False, check_filterable=True):
        """
        Build a WhereNode for a single filter clause but don't add it
        to this Query. Query.add_q() will then add this filter to the where
        Node.
    
        The 'branch_negated' tells us if the current branch contains any
        negations. This will be used to determine if subqueries are needed.
    
        The 'current_negated' is used to determine if the current filter is
        negated or not and this will be used to determine if IS NULL filtering
        is needed.
    
        The difference between current_negated and branch_negated is that
        branch_negated is set on first negation, but current_negated is
        flipped for each negation.
    
        Note that add_filter will not do any negating itself, that is done
        upper in the code by add_q().
    
        The 'can_reuse' is a set of reusable joins for multijoins.
    
        If 'reuse_with_filtered_relation' is True, then only joins in can_reuse
        will be reused.
    
        The method will create a filter clause that can be added to the current
        query. However, if the filter isn't added to the query then the caller
        is responsible for unreffing the joins used.
        """
        if isinstance(filter_expr, dict):
            raise FieldError("Cannot parse keyword query as dict")
        if isinstance(filter_expr, Q):
            return self._add_q(
                filter_expr,
                branch_negated=branch_negated,
                current_negated=current_negated,
                used_aliases=can_reuse,
                allow_joins=allow_joins,
                split_subq=split_subq,
                check_filterable=check_filterable,
            )
        if hasattr(filter_expr, 'resolve_expression'):
            if not getattr(filter_expr, 'conditional', False):
                raise TypeError('Cannot filter against a non-conditional expression.')
            condition = self.build_lookup(
                ['exact'], filter_expr.resolve_expression(self, allow_joins=allow_joins), True
            )
            clause = self.where_class()
            clause.add(condition, AND)
            return clause, []
        arg, value = filter_expr
        if not arg:
            raise FieldError("Cannot parse keyword query %r" % arg)
        lookups, parts, reffed_expression = self.solve_lookup_type(arg)
    
        if check_filterable:
            self.check_filterable(reffed_expression)
    
        if not allow_joins and len(parts) > 1:
            raise FieldError("Joined field references are not permitted in this query")
    
        pre_joins = self.alias_refcount.copy()
        value = self.resolve_lookup_value(value, can_reuse, allow_joins)
        used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
    
        if check_filterable:
            self.check_filterable(value)
    
        clause = self.where_class()
        if reffed_expression:
            condition = self.build_lookup(lookups, reffed_expression, value)
            clause.add(condition, AND)
            return clause, []
    
        opts = self.get_meta()
        alias = self.get_initial_alias()
        allow_many = not branch_negated or not split_subq
    
        try:
            join_info = self.setup_joins(
                parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
                reuse_with_filtered_relation=reuse_with_filtered_relation,
            )
    
            # Prevent iterator from being consumed by check_related_objects()
            if isinstance(value, Iterator):
                value = list(value)
            self.check_related_objects(join_info.final_field, value, join_info.opts)
    
            # split_exclude() needs to know which joins were generated for the
            # lookup parts
            self._lookup_joins = join_info.joins
        except MultiJoin as e:
            return self.split_exclude(filter_expr, can_reuse, e.names_with_path)
    
        # Update used_joins before trimming since they are reused to determine
        # which joins could be later promoted to INNER.
        used_joins.update(join_info.joins)
        targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
        if can_reuse is not None:
            can_reuse.update(join_list)
    
        if join_info.final_field.is_relation:
            # No support for transforms for relational fields
            num_lookups = len(lookups)
            if num_lookups > 1:
                raise FieldError('Related Field got invalid lookup: {}'.format(lookups[0]))
            if len(targets) == 1:
                col = self._get_col(targets[0], join_info.final_field, alias)
            else:
                col = MultiColSource(alias, targets, join_info.targets, join_info.final_field)
        else:
            col = self._get_col(targets[0], join_info.final_field, alias)
    
>       condition = self.build_lookup(lookups, col, value)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c1838940>
lookups = ['lt'], lhs = Col(blog_post, blog.Post.pub_date)
rhs = <function now at 0x7fc4c29e8d30>

    def build_lookup(self, lookups, lhs, rhs):
        """
        Try to extract transforms and lookup from given lhs.
    
        The lhs value is something that works like SQLExpression.
        The rhs value is what the lookup is going to compare against.
        The lookups is a list of names to extract using get_lookup()
        and get_transform().
        """
        # __exact is the default lookup if one isn't given.
        *transforms, lookup_name = lookups or ['exact']
        for name in transforms:
            lhs = self.try_transform(lhs, name)
        # First try get_lookup() so that the lookup takes precedence if the lhs
        # supports both transform and lookup for the name.
        lookup_class = lhs.get_lookup(lookup_name)
        if not lookup_class:
            if lhs.field.is_relation:
                raise FieldError('Related Field got invalid lookup: {}'.format(lookup_name))
            # A lookup wasn't found. Try to interpret the name as a transform
            # and do an Exact lookup against it.
            lhs = self.try_transform(lhs, lookup_name)
            lookup_name = 'exact'
            lookup_class = lhs.get_lookup(lookup_name)
            if not lookup_class:
                return
    
>       lookup = lookup_class(lhs, rhs)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1216: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.lookups.LessThan object at 0x7fc4c172e220>
lhs = Col(blog_post, blog.Post.pub_date), rhs = <function now at 0x7fc4c29e8d30>

    def __init__(self, lhs, rhs):
        self.lhs, self.rhs = lhs, rhs
>       self.rhs = self.get_prep_lookup()

venv/lib/python3.9/site-packages/django/db/models/lookups.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.lookups.LessThan object at 0x7fc4c172e220>

    def get_prep_lookup(self):
        if hasattr(self.rhs, 'resolve_expression'):
            return self.rhs
        if self.prepare_rhs and hasattr(self.lhs.output_field, 'get_prep_value'):
>           return self.lhs.output_field.get_prep_value(self.rhs)

venv/lib/python3.9/site-packages/django/db/models/lookups.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def get_prep_value(self, value):
>       value = super().get_prep_value(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1406: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def get_prep_value(self, value):
        value = super().get_prep_value(value)
>       return self.to_python(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def to_python(self, value):
        if value is None:
            return value
        if isinstance(value, datetime.datetime):
            return value
        if isinstance(value, datetime.date):
            value = datetime.datetime(value.year, value.month, value.day)
            if settings.USE_TZ:
                # For backwards compatibility, interpret naive datetimes in
                # local time. This won't work during DST change, but we can't
                # do much about it, so we let the exceptions percolate up the
                # call stack.
                warnings.warn("DateTimeField %s.%s received a naive datetime "
                              "(%s) while time zone support is active." %
                              (self.model.__name__, self.name, value),
                              RuntimeWarning)
                default_timezone = timezone.get_default_timezone()
                value = timezone.make_aware(value, default_timezone)
            return value
    
        try:
>           parsed = parse_datetime(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1367: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <function now at 0x7fc4c29e8d30>

    def parse_datetime(value):
        """Parse a string and return a datetime.datetime.
    
        This function supports time zone offsets. When the input contains one,
        the output uses a timezone with a fixed offset from UTC.
    
        Raise ValueError if the input is well formatted but not a valid datetime.
        Return None if the input isn't well formatted.
        """
>       match = datetime_re.match(value)
E       TypeError: expected string or bytes-like object

venv/lib/python3.9/site-packages/django/utils/dateparse.py:107: TypeError

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x7fc4c1a3b3a0>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)

tests/conftest.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_client = <django.test.client.Client object at 0x7fc4c1a3b3a0>
page_url = '/category/mission-high/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests/conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x7fc4c1a3b3a0>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests/conftest.py:141: AssertionError
---------------------------- Captured stdout setup -----------------------------
Operations to perform:
  Synchronize unmigrated apps: debug_toolbar, messages, staticfiles
  Apply all migrations: admin, auth, blog, contenttypes, sessions
Synchronizing apps without migrations:
  Creating tables...
    Running deferred SQL...
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying auth.0012_alter_user_first_name_max_length... OK
  Applying blog.0001_initial... OK
  Applying blog.0002_auto_20240928_1421... OK
  Applying blog.0003_alter_post_category... OK
  Applying blog.0004_alter_post_author... OK
  Applying sessions.0001_initial... OK
---------------------------- Captured stderr setup -----------------------------
Creating test database for alias 'default' ('file:memorydb_default?mode=memory&cache=shared')...
Internal Server Error: /category/mission-high/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
Internal Server Error: /category/mission-high/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
------------------------------ Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /category/mission-high/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
________ ERROR at setup of test_category_page_check_context_keys[title] ________

user_client = <django.test.client.Client object at 0x7fc4c0d7e610>
page_url = '/category/few-do-hand-rate/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests/conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c0d7e610>
path = '/category/few-do-hand-rate/', data = None, follow = False
secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv/lib/python3.9/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c0d7e610>
path = '/category/few-do-hand-rate/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv/lib/python3.9/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c0d7e610>, method = 'GET'
path = '/category/few-do-hand-rate/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/few-do-hand-rate/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/few-do-hand-rate/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv/lib/python3.9/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c0d7e610>
request = {'PATH_INFO': '/category/few-do-hand-rate/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=vn9tqbyksmbum0s6nguyiji6ibaa95g0', 'PATH_INFO': '/category/few-do-hand-rate/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'is_email': False, 'unicode_hint': '', 'frames': [{'exc_c...jango.template.base.Template object at 0x7fc4c0fdf850>, <django.template.base.Template object at 0x7fc4c0fdf850>, ...]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7fc4c22fbe50>, {'templates': [<django.template.base.Template...irst': False, 'last': True}, 'panel': <debug_toolbar.panels.profiling.ProfilingPanel object at 0x7fc4c0fc59d0>}, {}]]})
signal_uid = 'template-render-140483030835904'
exception_uid = 'request-exception-140483030835904'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv/lib/python3.9/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c0d7e610>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv/lib/python3.9/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/few-do-hand-rate/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7fc4c0d7e730>
request = <WSGIRequest: GET '/category/few-do-hand-rate/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv/lib/python3.9/site-packages/django/core/handlers/base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/few-do-hand-rate/'>
category_slug = 'few-do-hand-rate'

    def category_posts(request, category_slug):
        """View функция для страницы категорий."""
        try:
            category = Category.objects.get(slug=category_slug, is_published=True)
        except Category.DoesNotExist:
            raise Http404(f"Категория '{category_slug}' не найдена")
>       post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')

blogicum/blog/views.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.manager.Manager object at 0x7fc4c1838e50>, args = ()
kwargs = {'category': <Category: Black Dog Really Onto Season Sport>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def manager_method(self, *args, **kwargs):
>       return getattr(self.get_queryset(), name)(*args, **kwargs)

venv/lib/python3.9/site-packages/django/db/models/manager.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
args = ()
kwargs = {'category': <Category: Black Dog Really Onto Season Sport>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def filter(self, *args, **kwargs):
        """
        Return a new QuerySet instance with the args ANDed to the existing
        set.
        """
        self._not_support_combined_queries('filter')
>       return self._filter_or_exclude(False, args, kwargs)

venv/lib/python3.9/site-packages/django/db/models/query.py:941: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
negate = False, args = ()
kwargs = {'category': <Category: Black Dog Really Onto Season Sport>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def _filter_or_exclude(self, negate, args, kwargs):
        if args or kwargs:
            assert not self.query.is_sliced, \
                "Cannot filter a query once a slice has been taken."
    
        clone = self._chain()
        if self._defer_next_filter:
            self._defer_next_filter = False
            clone._deferred_filter = negate, args, kwargs
        else:
>           clone._filter_or_exclude_inplace(negate, args, kwargs)

venv/lib/python3.9/site-packages/django/db/models/query.py:961: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
negate = False, args = ()
kwargs = {'category': <Category: Black Dog Really Onto Season Sport>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def _filter_or_exclude_inplace(self, negate, args, kwargs):
        if negate:
            self._query.add_q(~Q(*args, **kwargs))
        else:
>           self._query.add_q(Q(*args, **kwargs))

venv/lib/python3.9/site-packages/django/db/models/query.py:968: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c0fdff70>
q_object = <Q: (AND: ('category', <Category: Black Dog Really Onto Season Sport>), ('is_published', True), ('pub_date__lt', <function now at 0x7fc4c29e8d30>))>

    def add_q(self, q_object):
        """
        A preprocessor for the internal _add_q(). Responsible for doing final
        join promotion.
        """
        # For join promotion this case is doing an AND for the added q_object
        # and existing conditions. So, any existing inner join forces the join
        # type to remain inner. Existing outer joins can however be demoted.
        # (Consider case where rel_a is LOUTER and rel_a__col=1 is added - if
        # rel_a doesn't produce any rows, then the whole condition must fail.
        # So, demotion is OK.
        existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
>       clause, _ = self._add_q(q_object, self.used_aliases)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c0fdff70>
q_object = <Q: (AND: ('category', <Category: Black Dog Really Onto Season Sport>), ('is_published', True), ('pub_date__lt', <function now at 0x7fc4c29e8d30>))>
used_aliases = {'blog_post'}, branch_negated = False, current_negated = False
allow_joins = True, split_subq = True, check_filterable = True

    def _add_q(self, q_object, used_aliases, branch_negated=False,
               current_negated=False, allow_joins=True, split_subq=True,
               check_filterable=True):
        """Add a Q-object to the current filter."""
        connector = q_object.connector
        current_negated = current_negated ^ q_object.negated
        branch_negated = branch_negated or q_object.negated
        target_clause = self.where_class(connector=connector,
                                         negated=q_object.negated)
        joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
        for child in q_object.children:
>           child_clause, needed_inner = self.build_filter(
                child, can_reuse=used_aliases, branch_negated=branch_negated,
                current_negated=current_negated, allow_joins=allow_joins,
                split_subq=split_subq, check_filterable=check_filterable,
            )

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1435: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c0fdff70>
filter_expr = ('pub_date__lt', <function now at 0x7fc4c29e8d30>)
branch_negated = False, current_negated = False, can_reuse = {'blog_post'}
allow_joins = True, split_subq = True, reuse_with_filtered_relation = False
check_filterable = True

    def build_filter(self, filter_expr, branch_negated=False, current_negated=False,
                     can_reuse=None, allow_joins=True, split_subq=True,
                     reuse_with_filtered_relation=False, check_filterable=True):
        """
        Build a WhereNode for a single filter clause but don't add it
        to this Query. Query.add_q() will then add this filter to the where
        Node.
    
        The 'branch_negated' tells us if the current branch contains any
        negations. This will be used to determine if subqueries are needed.
    
        The 'current_negated' is used to determine if the current filter is
        negated or not and this will be used to determine if IS NULL filtering
        is needed.
    
        The difference between current_negated and branch_negated is that
        branch_negated is set on first negation, but current_negated is
        flipped for each negation.
    
        Note that add_filter will not do any negating itself, that is done
        upper in the code by add_q().
    
        The 'can_reuse' is a set of reusable joins for multijoins.
    
        If 'reuse_with_filtered_relation' is True, then only joins in can_reuse
        will be reused.
    
        The method will create a filter clause that can be added to the current
        query. However, if the filter isn't added to the query then the caller
        is responsible for unreffing the joins used.
        """
        if isinstance(filter_expr, dict):
            raise FieldError("Cannot parse keyword query as dict")
        if isinstance(filter_expr, Q):
            return self._add_q(
                filter_expr,
                branch_negated=branch_negated,
                current_negated=current_negated,
                used_aliases=can_reuse,
                allow_joins=allow_joins,
                split_subq=split_subq,
                check_filterable=check_filterable,
            )
        if hasattr(filter_expr, 'resolve_expression'):
            if not getattr(filter_expr, 'conditional', False):
                raise TypeError('Cannot filter against a non-conditional expression.')
            condition = self.build_lookup(
                ['exact'], filter_expr.resolve_expression(self, allow_joins=allow_joins), True
            )
            clause = self.where_class()
            clause.add(condition, AND)
            return clause, []
        arg, value = filter_expr
        if not arg:
            raise FieldError("Cannot parse keyword query %r" % arg)
        lookups, parts, reffed_expression = self.solve_lookup_type(arg)
    
        if check_filterable:
            self.check_filterable(reffed_expression)
    
        if not allow_joins and len(parts) > 1:
            raise FieldError("Joined field references are not permitted in this query")
    
        pre_joins = self.alias_refcount.copy()
        value = self.resolve_lookup_value(value, can_reuse, allow_joins)
        used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
    
        if check_filterable:
            self.check_filterable(value)
    
        clause = self.where_class()
        if reffed_expression:
            condition = self.build_lookup(lookups, reffed_expression, value)
            clause.add(condition, AND)
            return clause, []
    
        opts = self.get_meta()
        alias = self.get_initial_alias()
        allow_many = not branch_negated or not split_subq
    
        try:
            join_info = self.setup_joins(
                parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
                reuse_with_filtered_relation=reuse_with_filtered_relation,
            )
    
            # Prevent iterator from being consumed by check_related_objects()
            if isinstance(value, Iterator):
                value = list(value)
            self.check_related_objects(join_info.final_field, value, join_info.opts)
    
            # split_exclude() needs to know which joins were generated for the
            # lookup parts
            self._lookup_joins = join_info.joins
        except MultiJoin as e:
            return self.split_exclude(filter_expr, can_reuse, e.names_with_path)
    
        # Update used_joins before trimming since they are reused to determine
        # which joins could be later promoted to INNER.
        used_joins.update(join_info.joins)
        targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
        if can_reuse is not None:
            can_reuse.update(join_list)
    
        if join_info.final_field.is_relation:
            # No support for transforms for relational fields
            num_lookups = len(lookups)
            if num_lookups > 1:
                raise FieldError('Related Field got invalid lookup: {}'.format(lookups[0]))
            if len(targets) == 1:
                col = self._get_col(targets[0], join_info.final_field, alias)
            else:
                col = MultiColSource(alias, targets, join_info.targets, join_info.final_field)
        else:
            col = self._get_col(targets[0], join_info.final_field, alias)
    
>       condition = self.build_lookup(lookups, col, value)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c0fdff70>
lookups = ['lt'], lhs = Col(blog_post, blog.Post.pub_date)
rhs = <function now at 0x7fc4c29e8d30>

    def build_lookup(self, lookups, lhs, rhs):
        """
        Try to extract transforms and lookup from given lhs.
    
        The lhs value is something that works like SQLExpression.
        The rhs value is what the lookup is going to compare against.
        The lookups is a list of names to extract using get_lookup()
        and get_transform().
        """
        # __exact is the default lookup if one isn't given.
        *transforms, lookup_name = lookups or ['exact']
        for name in transforms:
            lhs = self.try_transform(lhs, name)
        # First try get_lookup() so that the lookup takes precedence if the lhs
        # supports both transform and lookup for the name.
        lookup_class = lhs.get_lookup(lookup_name)
        if not lookup_class:
            if lhs.field.is_relation:
                raise FieldError('Related Field got invalid lookup: {}'.format(lookup_name))
            # A lookup wasn't found. Try to interpret the name as a transform
            # and do an Exact lookup against it.
            lhs = self.try_transform(lhs, lookup_name)
            lookup_name = 'exact'
            lookup_class = lhs.get_lookup(lookup_name)
            if not lookup_class:
                return
    
>       lookup = lookup_class(lhs, rhs)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1216: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.lookups.LessThan object at 0x7fc4c1092a30>
lhs = Col(blog_post, blog.Post.pub_date), rhs = <function now at 0x7fc4c29e8d30>

    def __init__(self, lhs, rhs):
        self.lhs, self.rhs = lhs, rhs
>       self.rhs = self.get_prep_lookup()

venv/lib/python3.9/site-packages/django/db/models/lookups.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.lookups.LessThan object at 0x7fc4c1092a30>

    def get_prep_lookup(self):
        if hasattr(self.rhs, 'resolve_expression'):
            return self.rhs
        if self.prepare_rhs and hasattr(self.lhs.output_field, 'get_prep_value'):
>           return self.lhs.output_field.get_prep_value(self.rhs)

venv/lib/python3.9/site-packages/django/db/models/lookups.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def get_prep_value(self, value):
>       value = super().get_prep_value(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1406: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def get_prep_value(self, value):
        value = super().get_prep_value(value)
>       return self.to_python(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def to_python(self, value):
        if value is None:
            return value
        if isinstance(value, datetime.datetime):
            return value
        if isinstance(value, datetime.date):
            value = datetime.datetime(value.year, value.month, value.day)
            if settings.USE_TZ:
                # For backwards compatibility, interpret naive datetimes in
                # local time. This won't work during DST change, but we can't
                # do much about it, so we let the exceptions percolate up the
                # call stack.
                warnings.warn("DateTimeField %s.%s received a naive datetime "
                              "(%s) while time zone support is active." %
                              (self.model.__name__, self.name, value),
                              RuntimeWarning)
                default_timezone = timezone.get_default_timezone()
                value = timezone.make_aware(value, default_timezone)
            return value
    
        try:
>           parsed = parse_datetime(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1367: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <function now at 0x7fc4c29e8d30>

    def parse_datetime(value):
        """Parse a string and return a datetime.datetime.
    
        This function supports time zone offsets. When the input contains one,
        the output uses a timezone with a fixed offset from UTC.
    
        Raise ValueError if the input is well formatted but not a valid datetime.
        Return None if the input isn't well formatted.
        """
>       match = datetime_re.match(value)
E       TypeError: expected string or bytes-like object

venv/lib/python3.9/site-packages/django/utils/dateparse.py:107: TypeError

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x7fc4c0d7e610>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)

tests/conftest.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_client = <django.test.client.Client object at 0x7fc4c0d7e610>
page_url = '/category/few-do-hand-rate/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests/conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x7fc4c0d7e610>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests/conftest.py:141: AssertionError
---------------------------- Captured stderr setup -----------------------------
Internal Server Error: /category/few-do-hand-rate/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
Internal Server Error: /category/few-do-hand-rate/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
------------------------------ Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /category/few-do-hand-rate/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
________ ERROR at setup of test_category_page_check_context_keys[key1] _________

user_client = <django.test.client.Client object at 0x7fc4c0d9a520>
page_url = '/category/beautiful-like-draw/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests/conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c0d9a520>
path = '/category/beautiful-like-draw/', data = None, follow = False
secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv/lib/python3.9/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c0d9a520>
path = '/category/beautiful-like-draw/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv/lib/python3.9/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c0d9a520>, method = 'GET'
path = '/category/beautiful-like-draw/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/beautiful-like-draw/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/beautiful-like-draw/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv/lib/python3.9/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c0d9a520>
request = {'PATH_INFO': '/category/beautiful-like-draw/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=4116sc2ez987n6nhoa4dymjhz7kw71uc', 'PATH_INFO': '/category/beautiful-like-draw/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'is_email': False, 'unicode_hint': '', 'frames': [{'exc_c...jango.template.base.Template object at 0x7fc4c0dcb730>, <django.template.base.Template object at 0x7fc4c0dcb730>, ...]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7fc4c22fbe50>, {'templates': [<django.template.base.Template...irst': False, 'last': True}, 'panel': <debug_toolbar.panels.profiling.ProfilingPanel object at 0x7fc4c0dba5b0>}, {}]]})
signal_uid = 'template-render-140483024948416'
exception_uid = 'request-exception-140483024948416'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv/lib/python3.9/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c0d9a520>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv/lib/python3.9/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/beautiful-like-draw/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7fc4c0d9a5b0>
request = <WSGIRequest: GET '/category/beautiful-like-draw/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv/lib/python3.9/site-packages/django/core/handlers/base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/beautiful-like-draw/'>
category_slug = 'beautiful-like-draw'

    def category_posts(request, category_slug):
        """View функция для страницы категорий."""
        try:
            category = Category.objects.get(slug=category_slug, is_published=True)
        except Category.DoesNotExist:
            raise Http404(f"Категория '{category_slug}' не найдена")
>       post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')

blogicum/blog/views.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.manager.Manager object at 0x7fc4c1838e50>, args = ()
kwargs = {'category': <Category: Option Memory Key Political Message Again>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def manager_method(self, *args, **kwargs):
>       return getattr(self.get_queryset(), name)(*args, **kwargs)

venv/lib/python3.9/site-packages/django/db/models/manager.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
args = ()
kwargs = {'category': <Category: Option Memory Key Political Message Again>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def filter(self, *args, **kwargs):
        """
        Return a new QuerySet instance with the args ANDed to the existing
        set.
        """
        self._not_support_combined_queries('filter')
>       return self._filter_or_exclude(False, args, kwargs)

venv/lib/python3.9/site-packages/django/db/models/query.py:941: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
negate = False, args = ()
kwargs = {'category': <Category: Option Memory Key Political Message Again>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def _filter_or_exclude(self, negate, args, kwargs):
        if args or kwargs:
            assert not self.query.is_sliced, \
                "Cannot filter a query once a slice has been taken."
    
        clone = self._chain()
        if self._defer_next_filter:
            self._defer_next_filter = False
            clone._deferred_filter = negate, args, kwargs
        else:
>           clone._filter_or_exclude_inplace(negate, args, kwargs)

venv/lib/python3.9/site-packages/django/db/models/query.py:961: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
negate = False, args = ()
kwargs = {'category': <Category: Option Memory Key Political Message Again>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def _filter_or_exclude_inplace(self, negate, args, kwargs):
        if negate:
            self._query.add_q(~Q(*args, **kwargs))
        else:
>           self._query.add_q(Q(*args, **kwargs))

venv/lib/python3.9/site-packages/django/db/models/query.py:968: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c0dcb3a0>
q_object = <Q: (AND: ('category', <Category: Option Memory Key Political Message Again>), ('is_published', True), ('pub_date__lt', <function now at 0x7fc4c29e8d30>))>

    def add_q(self, q_object):
        """
        A preprocessor for the internal _add_q(). Responsible for doing final
        join promotion.
        """
        # For join promotion this case is doing an AND for the added q_object
        # and existing conditions. So, any existing inner join forces the join
        # type to remain inner. Existing outer joins can however be demoted.
        # (Consider case where rel_a is LOUTER and rel_a__col=1 is added - if
        # rel_a doesn't produce any rows, then the whole condition must fail.
        # So, demotion is OK.
        existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
>       clause, _ = self._add_q(q_object, self.used_aliases)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c0dcb3a0>
q_object = <Q: (AND: ('category', <Category: Option Memory Key Political Message Again>), ('is_published', True), ('pub_date__lt', <function now at 0x7fc4c29e8d30>))>
used_aliases = {'blog_post'}, branch_negated = False, current_negated = False
allow_joins = True, split_subq = True, check_filterable = True

    def _add_q(self, q_object, used_aliases, branch_negated=False,
               current_negated=False, allow_joins=True, split_subq=True,
               check_filterable=True):
        """Add a Q-object to the current filter."""
        connector = q_object.connector
        current_negated = current_negated ^ q_object.negated
        branch_negated = branch_negated or q_object.negated
        target_clause = self.where_class(connector=connector,
                                         negated=q_object.negated)
        joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
        for child in q_object.children:
>           child_clause, needed_inner = self.build_filter(
                child, can_reuse=used_aliases, branch_negated=branch_negated,
                current_negated=current_negated, allow_joins=allow_joins,
                split_subq=split_subq, check_filterable=check_filterable,
            )

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1435: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c0dcb3a0>
filter_expr = ('pub_date__lt', <function now at 0x7fc4c29e8d30>)
branch_negated = False, current_negated = False, can_reuse = {'blog_post'}
allow_joins = True, split_subq = True, reuse_with_filtered_relation = False
check_filterable = True

    def build_filter(self, filter_expr, branch_negated=False, current_negated=False,
                     can_reuse=None, allow_joins=True, split_subq=True,
                     reuse_with_filtered_relation=False, check_filterable=True):
        """
        Build a WhereNode for a single filter clause but don't add it
        to this Query. Query.add_q() will then add this filter to the where
        Node.
    
        The 'branch_negated' tells us if the current branch contains any
        negations. This will be used to determine if subqueries are needed.
    
        The 'current_negated' is used to determine if the current filter is
        negated or not and this will be used to determine if IS NULL filtering
        is needed.
    
        The difference between current_negated and branch_negated is that
        branch_negated is set on first negation, but current_negated is
        flipped for each negation.
    
        Note that add_filter will not do any negating itself, that is done
        upper in the code by add_q().
    
        The 'can_reuse' is a set of reusable joins for multijoins.
    
        If 'reuse_with_filtered_relation' is True, then only joins in can_reuse
        will be reused.
    
        The method will create a filter clause that can be added to the current
        query. However, if the filter isn't added to the query then the caller
        is responsible for unreffing the joins used.
        """
        if isinstance(filter_expr, dict):
            raise FieldError("Cannot parse keyword query as dict")
        if isinstance(filter_expr, Q):
            return self._add_q(
                filter_expr,
                branch_negated=branch_negated,
                current_negated=current_negated,
                used_aliases=can_reuse,
                allow_joins=allow_joins,
                split_subq=split_subq,
                check_filterable=check_filterable,
            )
        if hasattr(filter_expr, 'resolve_expression'):
            if not getattr(filter_expr, 'conditional', False):
                raise TypeError('Cannot filter against a non-conditional expression.')
            condition = self.build_lookup(
                ['exact'], filter_expr.resolve_expression(self, allow_joins=allow_joins), True
            )
            clause = self.where_class()
            clause.add(condition, AND)
            return clause, []
        arg, value = filter_expr
        if not arg:
            raise FieldError("Cannot parse keyword query %r" % arg)
        lookups, parts, reffed_expression = self.solve_lookup_type(arg)
    
        if check_filterable:
            self.check_filterable(reffed_expression)
    
        if not allow_joins and len(parts) > 1:
            raise FieldError("Joined field references are not permitted in this query")
    
        pre_joins = self.alias_refcount.copy()
        value = self.resolve_lookup_value(value, can_reuse, allow_joins)
        used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
    
        if check_filterable:
            self.check_filterable(value)
    
        clause = self.where_class()
        if reffed_expression:
            condition = self.build_lookup(lookups, reffed_expression, value)
            clause.add(condition, AND)
            return clause, []
    
        opts = self.get_meta()
        alias = self.get_initial_alias()
        allow_many = not branch_negated or not split_subq
    
        try:
            join_info = self.setup_joins(
                parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
                reuse_with_filtered_relation=reuse_with_filtered_relation,
            )
    
            # Prevent iterator from being consumed by check_related_objects()
            if isinstance(value, Iterator):
                value = list(value)
            self.check_related_objects(join_info.final_field, value, join_info.opts)
    
            # split_exclude() needs to know which joins were generated for the
            # lookup parts
            self._lookup_joins = join_info.joins
        except MultiJoin as e:
            return self.split_exclude(filter_expr, can_reuse, e.names_with_path)
    
        # Update used_joins before trimming since they are reused to determine
        # which joins could be later promoted to INNER.
        used_joins.update(join_info.joins)
        targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
        if can_reuse is not None:
            can_reuse.update(join_list)
    
        if join_info.final_field.is_relation:
            # No support for transforms for relational fields
            num_lookups = len(lookups)
            if num_lookups > 1:
                raise FieldError('Related Field got invalid lookup: {}'.format(lookups[0]))
            if len(targets) == 1:
                col = self._get_col(targets[0], join_info.final_field, alias)
            else:
                col = MultiColSource(alias, targets, join_info.targets, join_info.final_field)
        else:
            col = self._get_col(targets[0], join_info.final_field, alias)
    
>       condition = self.build_lookup(lookups, col, value)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c0dcb3a0>
lookups = ['lt'], lhs = Col(blog_post, blog.Post.pub_date)
rhs = <function now at 0x7fc4c29e8d30>

    def build_lookup(self, lookups, lhs, rhs):
        """
        Try to extract transforms and lookup from given lhs.
    
        The lhs value is something that works like SQLExpression.
        The rhs value is what the lookup is going to compare against.
        The lookups is a list of names to extract using get_lookup()
        and get_transform().
        """
        # __exact is the default lookup if one isn't given.
        *transforms, lookup_name = lookups or ['exact']
        for name in transforms:
            lhs = self.try_transform(lhs, name)
        # First try get_lookup() so that the lookup takes precedence if the lhs
        # supports both transform and lookup for the name.
        lookup_class = lhs.get_lookup(lookup_name)
        if not lookup_class:
            if lhs.field.is_relation:
                raise FieldError('Related Field got invalid lookup: {}'.format(lookup_name))
            # A lookup wasn't found. Try to interpret the name as a transform
            # and do an Exact lookup against it.
            lhs = self.try_transform(lhs, lookup_name)
            lookup_name = 'exact'
            lookup_class = lhs.get_lookup(lookup_name)
            if not lookup_class:
                return
    
>       lookup = lookup_class(lhs, rhs)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1216: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.lookups.LessThan object at 0x7fc4c0b6c7f0>
lhs = Col(blog_post, blog.Post.pub_date), rhs = <function now at 0x7fc4c29e8d30>

    def __init__(self, lhs, rhs):
        self.lhs, self.rhs = lhs, rhs
>       self.rhs = self.get_prep_lookup()

venv/lib/python3.9/site-packages/django/db/models/lookups.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.lookups.LessThan object at 0x7fc4c0b6c7f0>

    def get_prep_lookup(self):
        if hasattr(self.rhs, 'resolve_expression'):
            return self.rhs
        if self.prepare_rhs and hasattr(self.lhs.output_field, 'get_prep_value'):
>           return self.lhs.output_field.get_prep_value(self.rhs)

venv/lib/python3.9/site-packages/django/db/models/lookups.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def get_prep_value(self, value):
>       value = super().get_prep_value(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1406: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def get_prep_value(self, value):
        value = super().get_prep_value(value)
>       return self.to_python(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def to_python(self, value):
        if value is None:
            return value
        if isinstance(value, datetime.datetime):
            return value
        if isinstance(value, datetime.date):
            value = datetime.datetime(value.year, value.month, value.day)
            if settings.USE_TZ:
                # For backwards compatibility, interpret naive datetimes in
                # local time. This won't work during DST change, but we can't
                # do much about it, so we let the exceptions percolate up the
                # call stack.
                warnings.warn("DateTimeField %s.%s received a naive datetime "
                              "(%s) while time zone support is active." %
                              (self.model.__name__, self.name, value),
                              RuntimeWarning)
                default_timezone = timezone.get_default_timezone()
                value = timezone.make_aware(value, default_timezone)
            return value
    
        try:
>           parsed = parse_datetime(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1367: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <function now at 0x7fc4c29e8d30>

    def parse_datetime(value):
        """Parse a string and return a datetime.datetime.
    
        This function supports time zone offsets. When the input contains one,
        the output uses a timezone with a fixed offset from UTC.
    
        Raise ValueError if the input is well formatted but not a valid datetime.
        Return None if the input isn't well formatted.
        """
>       match = datetime_re.match(value)
E       TypeError: expected string or bytes-like object

venv/lib/python3.9/site-packages/django/utils/dateparse.py:107: TypeError

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x7fc4c0d9a520>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)

tests/conftest.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_client = <django.test.client.Client object at 0x7fc4c0d9a520>
page_url = '/category/beautiful-like-draw/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests/conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x7fc4c0d9a520>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests/conftest.py:141: AssertionError
---------------------------- Captured stderr setup -----------------------------
Internal Server Error: /category/beautiful-like-draw/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
Internal Server Error: /category/beautiful-like-draw/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
------------------------------ Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /category/beautiful-like-draw/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
________ ERROR at setup of test_category_page_check_context_keys[key2] _________

user_client = <django.test.client.Client object at 0x7fc4c0e378b0>
page_url = '/category/each-field-range/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests/conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c0e378b0>
path = '/category/each-field-range/', data = None, follow = False
secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv/lib/python3.9/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c0e378b0>
path = '/category/each-field-range/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv/lib/python3.9/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c0e378b0>, method = 'GET'
path = '/category/each-field-range/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/each-field-range/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/each-field-range/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv/lib/python3.9/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c0e378b0>
request = {'PATH_INFO': '/category/each-field-range/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=w9xzj7lhzfuk6zxatonfv0awy5ig112k', 'PATH_INFO': '/category/each-field-range/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'is_email': False, 'unicode_hint': '', 'frames': [{'exc_c...jango.template.base.Template object at 0x7fc4c0b2b490>, <django.template.base.Template object at 0x7fc4c0b2b490>, ...]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7fc4c22fbe50>, {'templates': [<django.template.base.Template...irst': False, 'last': True}, 'panel': <debug_toolbar.panels.profiling.ProfilingPanel object at 0x7fc4c0b1eb50>}, {}]]})
signal_uid = 'template-render-140483022612928'
exception_uid = 'request-exception-140483022612928'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv/lib/python3.9/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c0e378b0>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv/lib/python3.9/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/each-field-range/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7fc4c0e37820>
request = <WSGIRequest: GET '/category/each-field-range/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv/lib/python3.9/site-packages/django/core/handlers/base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/each-field-range/'>
category_slug = 'each-field-range'

    def category_posts(request, category_slug):
        """View функция для страницы категорий."""
        try:
            category = Category.objects.get(slug=category_slug, is_published=True)
        except Category.DoesNotExist:
            raise Http404(f"Категория '{category_slug}' не найдена")
>       post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')

blogicum/blog/views.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.manager.Manager object at 0x7fc4c1838e50>, args = ()
kwargs = {'category': <Category: Certainly On Consumer I Parent Apply>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def manager_method(self, *args, **kwargs):
>       return getattr(self.get_queryset(), name)(*args, **kwargs)

venv/lib/python3.9/site-packages/django/db/models/manager.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
args = ()
kwargs = {'category': <Category: Certainly On Consumer I Parent Apply>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def filter(self, *args, **kwargs):
        """
        Return a new QuerySet instance with the args ANDed to the existing
        set.
        """
        self._not_support_combined_queries('filter')
>       return self._filter_or_exclude(False, args, kwargs)

venv/lib/python3.9/site-packages/django/db/models/query.py:941: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
negate = False, args = ()
kwargs = {'category': <Category: Certainly On Consumer I Parent Apply>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def _filter_or_exclude(self, negate, args, kwargs):
        if args or kwargs:
            assert not self.query.is_sliced, \
                "Cannot filter a query once a slice has been taken."
    
        clone = self._chain()
        if self._defer_next_filter:
            self._defer_next_filter = False
            clone._deferred_filter = negate, args, kwargs
        else:
>           clone._filter_or_exclude_inplace(negate, args, kwargs)

venv/lib/python3.9/site-packages/django/db/models/query.py:961: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
negate = False, args = ()
kwargs = {'category': <Category: Certainly On Consumer I Parent Apply>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def _filter_or_exclude_inplace(self, negate, args, kwargs):
        if negate:
            self._query.add_q(~Q(*args, **kwargs))
        else:
>           self._query.add_q(Q(*args, **kwargs))

venv/lib/python3.9/site-packages/django/db/models/query.py:968: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c10e9700>
q_object = <Q: (AND: ('category', <Category: Certainly On Consumer I Parent Apply>), ('is_published', True), ('pub_date__lt', <function now at 0x7fc4c29e8d30>))>

    def add_q(self, q_object):
        """
        A preprocessor for the internal _add_q(). Responsible for doing final
        join promotion.
        """
        # For join promotion this case is doing an AND for the added q_object
        # and existing conditions. So, any existing inner join forces the join
        # type to remain inner. Existing outer joins can however be demoted.
        # (Consider case where rel_a is LOUTER and rel_a__col=1 is added - if
        # rel_a doesn't produce any rows, then the whole condition must fail.
        # So, demotion is OK.
        existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
>       clause, _ = self._add_q(q_object, self.used_aliases)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c10e9700>
q_object = <Q: (AND: ('category', <Category: Certainly On Consumer I Parent Apply>), ('is_published', True), ('pub_date__lt', <function now at 0x7fc4c29e8d30>))>
used_aliases = {'blog_post'}, branch_negated = False, current_negated = False
allow_joins = True, split_subq = True, check_filterable = True

    def _add_q(self, q_object, used_aliases, branch_negated=False,
               current_negated=False, allow_joins=True, split_subq=True,
               check_filterable=True):
        """Add a Q-object to the current filter."""
        connector = q_object.connector
        current_negated = current_negated ^ q_object.negated
        branch_negated = branch_negated or q_object.negated
        target_clause = self.where_class(connector=connector,
                                         negated=q_object.negated)
        joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
        for child in q_object.children:
>           child_clause, needed_inner = self.build_filter(
                child, can_reuse=used_aliases, branch_negated=branch_negated,
                current_negated=current_negated, allow_joins=allow_joins,
                split_subq=split_subq, check_filterable=check_filterable,
            )

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1435: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c10e9700>
filter_expr = ('pub_date__lt', <function now at 0x7fc4c29e8d30>)
branch_negated = False, current_negated = False, can_reuse = {'blog_post'}
allow_joins = True, split_subq = True, reuse_with_filtered_relation = False
check_filterable = True

    def build_filter(self, filter_expr, branch_negated=False, current_negated=False,
                     can_reuse=None, allow_joins=True, split_subq=True,
                     reuse_with_filtered_relation=False, check_filterable=True):
        """
        Build a WhereNode for a single filter clause but don't add it
        to this Query. Query.add_q() will then add this filter to the where
        Node.
    
        The 'branch_negated' tells us if the current branch contains any
        negations. This will be used to determine if subqueries are needed.
    
        The 'current_negated' is used to determine if the current filter is
        negated or not and this will be used to determine if IS NULL filtering
        is needed.
    
        The difference between current_negated and branch_negated is that
        branch_negated is set on first negation, but current_negated is
        flipped for each negation.
    
        Note that add_filter will not do any negating itself, that is done
        upper in the code by add_q().
    
        The 'can_reuse' is a set of reusable joins for multijoins.
    
        If 'reuse_with_filtered_relation' is True, then only joins in can_reuse
        will be reused.
    
        The method will create a filter clause that can be added to the current
        query. However, if the filter isn't added to the query then the caller
        is responsible for unreffing the joins used.
        """
        if isinstance(filter_expr, dict):
            raise FieldError("Cannot parse keyword query as dict")
        if isinstance(filter_expr, Q):
            return self._add_q(
                filter_expr,
                branch_negated=branch_negated,
                current_negated=current_negated,
                used_aliases=can_reuse,
                allow_joins=allow_joins,
                split_subq=split_subq,
                check_filterable=check_filterable,
            )
        if hasattr(filter_expr, 'resolve_expression'):
            if not getattr(filter_expr, 'conditional', False):
                raise TypeError('Cannot filter against a non-conditional expression.')
            condition = self.build_lookup(
                ['exact'], filter_expr.resolve_expression(self, allow_joins=allow_joins), True
            )
            clause = self.where_class()
            clause.add(condition, AND)
            return clause, []
        arg, value = filter_expr
        if not arg:
            raise FieldError("Cannot parse keyword query %r" % arg)
        lookups, parts, reffed_expression = self.solve_lookup_type(arg)
    
        if check_filterable:
            self.check_filterable(reffed_expression)
    
        if not allow_joins and len(parts) > 1:
            raise FieldError("Joined field references are not permitted in this query")
    
        pre_joins = self.alias_refcount.copy()
        value = self.resolve_lookup_value(value, can_reuse, allow_joins)
        used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
    
        if check_filterable:
            self.check_filterable(value)
    
        clause = self.where_class()
        if reffed_expression:
            condition = self.build_lookup(lookups, reffed_expression, value)
            clause.add(condition, AND)
            return clause, []
    
        opts = self.get_meta()
        alias = self.get_initial_alias()
        allow_many = not branch_negated or not split_subq
    
        try:
            join_info = self.setup_joins(
                parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
                reuse_with_filtered_relation=reuse_with_filtered_relation,
            )
    
            # Prevent iterator from being consumed by check_related_objects()
            if isinstance(value, Iterator):
                value = list(value)
            self.check_related_objects(join_info.final_field, value, join_info.opts)
    
            # split_exclude() needs to know which joins were generated for the
            # lookup parts
            self._lookup_joins = join_info.joins
        except MultiJoin as e:
            return self.split_exclude(filter_expr, can_reuse, e.names_with_path)
    
        # Update used_joins before trimming since they are reused to determine
        # which joins could be later promoted to INNER.
        used_joins.update(join_info.joins)
        targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
        if can_reuse is not None:
            can_reuse.update(join_list)
    
        if join_info.final_field.is_relation:
            # No support for transforms for relational fields
            num_lookups = len(lookups)
            if num_lookups > 1:
                raise FieldError('Related Field got invalid lookup: {}'.format(lookups[0]))
            if len(targets) == 1:
                col = self._get_col(targets[0], join_info.final_field, alias)
            else:
                col = MultiColSource(alias, targets, join_info.targets, join_info.final_field)
        else:
            col = self._get_col(targets[0], join_info.final_field, alias)
    
>       condition = self.build_lookup(lookups, col, value)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c10e9700>
lookups = ['lt'], lhs = Col(blog_post, blog.Post.pub_date)
rhs = <function now at 0x7fc4c29e8d30>

    def build_lookup(self, lookups, lhs, rhs):
        """
        Try to extract transforms and lookup from given lhs.
    
        The lhs value is something that works like SQLExpression.
        The rhs value is what the lookup is going to compare against.
        The lookups is a list of names to extract using get_lookup()
        and get_transform().
        """
        # __exact is the default lookup if one isn't given.
        *transforms, lookup_name = lookups or ['exact']
        for name in transforms:
            lhs = self.try_transform(lhs, name)
        # First try get_lookup() so that the lookup takes precedence if the lhs
        # supports both transform and lookup for the name.
        lookup_class = lhs.get_lookup(lookup_name)
        if not lookup_class:
            if lhs.field.is_relation:
                raise FieldError('Related Field got invalid lookup: {}'.format(lookup_name))
            # A lookup wasn't found. Try to interpret the name as a transform
            # and do an Exact lookup against it.
            lhs = self.try_transform(lhs, lookup_name)
            lookup_name = 'exact'
            lookup_class = lhs.get_lookup(lookup_name)
            if not lookup_class:
                return
    
>       lookup = lookup_class(lhs, rhs)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1216: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.lookups.LessThan object at 0x7fc4c10e9ee0>
lhs = Col(blog_post, blog.Post.pub_date), rhs = <function now at 0x7fc4c29e8d30>

    def __init__(self, lhs, rhs):
        self.lhs, self.rhs = lhs, rhs
>       self.rhs = self.get_prep_lookup()

venv/lib/python3.9/site-packages/django/db/models/lookups.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.lookups.LessThan object at 0x7fc4c10e9ee0>

    def get_prep_lookup(self):
        if hasattr(self.rhs, 'resolve_expression'):
            return self.rhs
        if self.prepare_rhs and hasattr(self.lhs.output_field, 'get_prep_value'):
>           return self.lhs.output_field.get_prep_value(self.rhs)

venv/lib/python3.9/site-packages/django/db/models/lookups.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def get_prep_value(self, value):
>       value = super().get_prep_value(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1406: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def get_prep_value(self, value):
        value = super().get_prep_value(value)
>       return self.to_python(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def to_python(self, value):
        if value is None:
            return value
        if isinstance(value, datetime.datetime):
            return value
        if isinstance(value, datetime.date):
            value = datetime.datetime(value.year, value.month, value.day)
            if settings.USE_TZ:
                # For backwards compatibility, interpret naive datetimes in
                # local time. This won't work during DST change, but we can't
                # do much about it, so we let the exceptions percolate up the
                # call stack.
                warnings.warn("DateTimeField %s.%s received a naive datetime "
                              "(%s) while time zone support is active." %
                              (self.model.__name__, self.name, value),
                              RuntimeWarning)
                default_timezone = timezone.get_default_timezone()
                value = timezone.make_aware(value, default_timezone)
            return value
    
        try:
>           parsed = parse_datetime(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1367: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <function now at 0x7fc4c29e8d30>

    def parse_datetime(value):
        """Parse a string and return a datetime.datetime.
    
        This function supports time zone offsets. When the input contains one,
        the output uses a timezone with a fixed offset from UTC.
    
        Raise ValueError if the input is well formatted but not a valid datetime.
        Return None if the input isn't well formatted.
        """
>       match = datetime_re.match(value)
E       TypeError: expected string or bytes-like object

venv/lib/python3.9/site-packages/django/utils/dateparse.py:107: TypeError

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x7fc4c0e378b0>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)

tests/conftest.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_client = <django.test.client.Client object at 0x7fc4c0e378b0>
page_url = '/category/each-field-range/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests/conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x7fc4c0e378b0>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests/conftest.py:141: AssertionError
---------------------------- Captured stderr setup -----------------------------
Internal Server Error: /category/each-field-range/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
Internal Server Error: /category/each-field-range/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
------------------------------ Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /category/each-field-range/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
________ ERROR at setup of test_category_page_check_context_keys[key3] _________

user_client = <django.test.client.Client object at 0x7fc4c06eaca0>
page_url = '/category/enjoy-hair-growth/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests/conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c06eaca0>
path = '/category/enjoy-hair-growth/', data = None, follow = False
secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv/lib/python3.9/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c06eaca0>
path = '/category/enjoy-hair-growth/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv/lib/python3.9/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c06eaca0>, method = 'GET'
path = '/category/enjoy-hair-growth/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/enjoy-hair-growth/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/enjoy-hair-growth/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv/lib/python3.9/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c06eaca0>
request = {'PATH_INFO': '/category/enjoy-hair-growth/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=j7e4bz2etc6v0dq2vs4xej4pxfxo64qt', 'PATH_INFO': '/category/enjoy-hair-growth/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'is_email': False, 'unicode_hint': '', 'frames': [{'exc_c...jango.template.base.Template object at 0x7fc4c10c1eb0>, <django.template.base.Template object at 0x7fc4c10c1eb0>, ...]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7fc4c22fbe50>, {'templates': [<django.template.base.Template...irst': False, 'last': True}, 'panel': <debug_toolbar.panels.profiling.ProfilingPanel object at 0x7fc4c06d9b80>}, {}]]})
signal_uid = 'template-render-140483019073536'
exception_uid = 'request-exception-140483019073536'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv/lib/python3.9/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c06eaca0>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv/lib/python3.9/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/enjoy-hair-growth/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7fc4c06ea970>
request = <WSGIRequest: GET '/category/enjoy-hair-growth/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv/lib/python3.9/site-packages/django/core/handlers/base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/enjoy-hair-growth/'>
category_slug = 'enjoy-hair-growth'

    def category_posts(request, category_slug):
        """View функция для страницы категорий."""
        try:
            category = Category.objects.get(slug=category_slug, is_published=True)
        except Category.DoesNotExist:
            raise Http404(f"Категория '{category_slug}' не найдена")
>       post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')

blogicum/blog/views.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.manager.Manager object at 0x7fc4c1838e50>, args = ()
kwargs = {'category': <Category: Dog Modern Your Less Special Tend>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def manager_method(self, *args, **kwargs):
>       return getattr(self.get_queryset(), name)(*args, **kwargs)

venv/lib/python3.9/site-packages/django/db/models/manager.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
args = ()
kwargs = {'category': <Category: Dog Modern Your Less Special Tend>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def filter(self, *args, **kwargs):
        """
        Return a new QuerySet instance with the args ANDed to the existing
        set.
        """
        self._not_support_combined_queries('filter')
>       return self._filter_or_exclude(False, args, kwargs)

venv/lib/python3.9/site-packages/django/db/models/query.py:941: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
negate = False, args = ()
kwargs = {'category': <Category: Dog Modern Your Less Special Tend>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def _filter_or_exclude(self, negate, args, kwargs):
        if args or kwargs:
            assert not self.query.is_sliced, \
                "Cannot filter a query once a slice has been taken."
    
        clone = self._chain()
        if self._defer_next_filter:
            self._defer_next_filter = False
            clone._deferred_filter = negate, args, kwargs
        else:
>           clone._filter_or_exclude_inplace(negate, args, kwargs)

venv/lib/python3.9/site-packages/django/db/models/query.py:961: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
negate = False, args = ()
kwargs = {'category': <Category: Dog Modern Your Less Special Tend>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def _filter_or_exclude_inplace(self, negate, args, kwargs):
        if negate:
            self._query.add_q(~Q(*args, **kwargs))
        else:
>           self._query.add_q(Q(*args, **kwargs))

venv/lib/python3.9/site-packages/django/db/models/query.py:968: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c10c1490>
q_object = <Q: (AND: ('category', <Category: Dog Modern Your Less Special Tend>), ('is_published', True), ('pub_date__lt', <function now at 0x7fc4c29e8d30>))>

    def add_q(self, q_object):
        """
        A preprocessor for the internal _add_q(). Responsible for doing final
        join promotion.
        """
        # For join promotion this case is doing an AND for the added q_object
        # and existing conditions. So, any existing inner join forces the join
        # type to remain inner. Existing outer joins can however be demoted.
        # (Consider case where rel_a is LOUTER and rel_a__col=1 is added - if
        # rel_a doesn't produce any rows, then the whole condition must fail.
        # So, demotion is OK.
        existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
>       clause, _ = self._add_q(q_object, self.used_aliases)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c10c1490>
q_object = <Q: (AND: ('category', <Category: Dog Modern Your Less Special Tend>), ('is_published', True), ('pub_date__lt', <function now at 0x7fc4c29e8d30>))>
used_aliases = {'blog_post'}, branch_negated = False, current_negated = False
allow_joins = True, split_subq = True, check_filterable = True

    def _add_q(self, q_object, used_aliases, branch_negated=False,
               current_negated=False, allow_joins=True, split_subq=True,
               check_filterable=True):
        """Add a Q-object to the current filter."""
        connector = q_object.connector
        current_negated = current_negated ^ q_object.negated
        branch_negated = branch_negated or q_object.negated
        target_clause = self.where_class(connector=connector,
                                         negated=q_object.negated)
        joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
        for child in q_object.children:
>           child_clause, needed_inner = self.build_filter(
                child, can_reuse=used_aliases, branch_negated=branch_negated,
                current_negated=current_negated, allow_joins=allow_joins,
                split_subq=split_subq, check_filterable=check_filterable,
            )

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1435: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c10c1490>
filter_expr = ('pub_date__lt', <function now at 0x7fc4c29e8d30>)
branch_negated = False, current_negated = False, can_reuse = {'blog_post'}
allow_joins = True, split_subq = True, reuse_with_filtered_relation = False
check_filterable = True

    def build_filter(self, filter_expr, branch_negated=False, current_negated=False,
                     can_reuse=None, allow_joins=True, split_subq=True,
                     reuse_with_filtered_relation=False, check_filterable=True):
        """
        Build a WhereNode for a single filter clause but don't add it
        to this Query. Query.add_q() will then add this filter to the where
        Node.
    
        The 'branch_negated' tells us if the current branch contains any
        negations. This will be used to determine if subqueries are needed.
    
        The 'current_negated' is used to determine if the current filter is
        negated or not and this will be used to determine if IS NULL filtering
        is needed.
    
        The difference between current_negated and branch_negated is that
        branch_negated is set on first negation, but current_negated is
        flipped for each negation.
    
        Note that add_filter will not do any negating itself, that is done
        upper in the code by add_q().
    
        The 'can_reuse' is a set of reusable joins for multijoins.
    
        If 'reuse_with_filtered_relation' is True, then only joins in can_reuse
        will be reused.
    
        The method will create a filter clause that can be added to the current
        query. However, if the filter isn't added to the query then the caller
        is responsible for unreffing the joins used.
        """
        if isinstance(filter_expr, dict):
            raise FieldError("Cannot parse keyword query as dict")
        if isinstance(filter_expr, Q):
            return self._add_q(
                filter_expr,
                branch_negated=branch_negated,
                current_negated=current_negated,
                used_aliases=can_reuse,
                allow_joins=allow_joins,
                split_subq=split_subq,
                check_filterable=check_filterable,
            )
        if hasattr(filter_expr, 'resolve_expression'):
            if not getattr(filter_expr, 'conditional', False):
                raise TypeError('Cannot filter against a non-conditional expression.')
            condition = self.build_lookup(
                ['exact'], filter_expr.resolve_expression(self, allow_joins=allow_joins), True
            )
            clause = self.where_class()
            clause.add(condition, AND)
            return clause, []
        arg, value = filter_expr
        if not arg:
            raise FieldError("Cannot parse keyword query %r" % arg)
        lookups, parts, reffed_expression = self.solve_lookup_type(arg)
    
        if check_filterable:
            self.check_filterable(reffed_expression)
    
        if not allow_joins and len(parts) > 1:
            raise FieldError("Joined field references are not permitted in this query")
    
        pre_joins = self.alias_refcount.copy()
        value = self.resolve_lookup_value(value, can_reuse, allow_joins)
        used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
    
        if check_filterable:
            self.check_filterable(value)
    
        clause = self.where_class()
        if reffed_expression:
            condition = self.build_lookup(lookups, reffed_expression, value)
            clause.add(condition, AND)
            return clause, []
    
        opts = self.get_meta()
        alias = self.get_initial_alias()
        allow_many = not branch_negated or not split_subq
    
        try:
            join_info = self.setup_joins(
                parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
                reuse_with_filtered_relation=reuse_with_filtered_relation,
            )
    
            # Prevent iterator from being consumed by check_related_objects()
            if isinstance(value, Iterator):
                value = list(value)
            self.check_related_objects(join_info.final_field, value, join_info.opts)
    
            # split_exclude() needs to know which joins were generated for the
            # lookup parts
            self._lookup_joins = join_info.joins
        except MultiJoin as e:
            return self.split_exclude(filter_expr, can_reuse, e.names_with_path)
    
        # Update used_joins before trimming since they are reused to determine
        # which joins could be later promoted to INNER.
        used_joins.update(join_info.joins)
        targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
        if can_reuse is not None:
            can_reuse.update(join_list)
    
        if join_info.final_field.is_relation:
            # No support for transforms for relational fields
            num_lookups = len(lookups)
            if num_lookups > 1:
                raise FieldError('Related Field got invalid lookup: {}'.format(lookups[0]))
            if len(targets) == 1:
                col = self._get_col(targets[0], join_info.final_field, alias)
            else:
                col = MultiColSource(alias, targets, join_info.targets, join_info.final_field)
        else:
            col = self._get_col(targets[0], join_info.final_field, alias)
    
>       condition = self.build_lookup(lookups, col, value)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c10c1490>
lookups = ['lt'], lhs = Col(blog_post, blog.Post.pub_date)
rhs = <function now at 0x7fc4c29e8d30>

    def build_lookup(self, lookups, lhs, rhs):
        """
        Try to extract transforms and lookup from given lhs.
    
        The lhs value is something that works like SQLExpression.
        The rhs value is what the lookup is going to compare against.
        The lookups is a list of names to extract using get_lookup()
        and get_transform().
        """
        # __exact is the default lookup if one isn't given.
        *transforms, lookup_name = lookups or ['exact']
        for name in transforms:
            lhs = self.try_transform(lhs, name)
        # First try get_lookup() so that the lookup takes precedence if the lhs
        # supports both transform and lookup for the name.
        lookup_class = lhs.get_lookup(lookup_name)
        if not lookup_class:
            if lhs.field.is_relation:
                raise FieldError('Related Field got invalid lookup: {}'.format(lookup_name))
            # A lookup wasn't found. Try to interpret the name as a transform
            # and do an Exact lookup against it.
            lhs = self.try_transform(lhs, lookup_name)
            lookup_name = 'exact'
            lookup_class = lhs.get_lookup(lookup_name)
            if not lookup_class:
                return
    
>       lookup = lookup_class(lhs, rhs)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1216: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.lookups.LessThan object at 0x7fc4c10b93d0>
lhs = Col(blog_post, blog.Post.pub_date), rhs = <function now at 0x7fc4c29e8d30>

    def __init__(self, lhs, rhs):
        self.lhs, self.rhs = lhs, rhs
>       self.rhs = self.get_prep_lookup()

venv/lib/python3.9/site-packages/django/db/models/lookups.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.lookups.LessThan object at 0x7fc4c10b93d0>

    def get_prep_lookup(self):
        if hasattr(self.rhs, 'resolve_expression'):
            return self.rhs
        if self.prepare_rhs and hasattr(self.lhs.output_field, 'get_prep_value'):
>           return self.lhs.output_field.get_prep_value(self.rhs)

venv/lib/python3.9/site-packages/django/db/models/lookups.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def get_prep_value(self, value):
>       value = super().get_prep_value(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1406: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def get_prep_value(self, value):
        value = super().get_prep_value(value)
>       return self.to_python(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def to_python(self, value):
        if value is None:
            return value
        if isinstance(value, datetime.datetime):
            return value
        if isinstance(value, datetime.date):
            value = datetime.datetime(value.year, value.month, value.day)
            if settings.USE_TZ:
                # For backwards compatibility, interpret naive datetimes in
                # local time. This won't work during DST change, but we can't
                # do much about it, so we let the exceptions percolate up the
                # call stack.
                warnings.warn("DateTimeField %s.%s received a naive datetime "
                              "(%s) while time zone support is active." %
                              (self.model.__name__, self.name, value),
                              RuntimeWarning)
                default_timezone = timezone.get_default_timezone()
                value = timezone.make_aware(value, default_timezone)
            return value
    
        try:
>           parsed = parse_datetime(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1367: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <function now at 0x7fc4c29e8d30>

    def parse_datetime(value):
        """Parse a string and return a datetime.datetime.
    
        This function supports time zone offsets. When the input contains one,
        the output uses a timezone with a fixed offset from UTC.
    
        Raise ValueError if the input is well formatted but not a valid datetime.
        Return None if the input isn't well formatted.
        """
>       match = datetime_re.match(value)
E       TypeError: expected string or bytes-like object

venv/lib/python3.9/site-packages/django/utils/dateparse.py:107: TypeError

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x7fc4c06eaca0>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)

tests/conftest.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_client = <django.test.client.Client object at 0x7fc4c06eaca0>
page_url = '/category/enjoy-hair-growth/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests/conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x7fc4c06eaca0>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests/conftest.py:141: AssertionError
---------------------------- Captured stderr setup -----------------------------
Internal Server Error: /category/enjoy-hair-growth/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
Internal Server Error: /category/enjoy-hair-growth/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
------------------------------ Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /category/enjoy-hair-growth/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
__________ ERROR at setup of test_category_page_category_unpublished ___________

user_client = <django.test.client.Client object at 0x7fc4c0767cd0>
page_url = '/category/term-late-else/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests/conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c0767cd0>
path = '/category/term-late-else/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv/lib/python3.9/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c0767cd0>
path = '/category/term-late-else/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv/lib/python3.9/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c0767cd0>, method = 'GET'
path = '/category/term-late-else/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/term-late-else/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/term-late-else/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv/lib/python3.9/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c0767cd0>
request = {'PATH_INFO': '/category/term-late-else/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=f5b374hd7ekfpap74n0uvg6745u31l6f', 'PATH_INFO': '/category/term-late-else/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'is_email': False, 'unicode_hint': '', 'frames': [{'exc_c...jango.template.base.Template object at 0x7fc4c0f1c3a0>, <django.template.base.Template object at 0x7fc4c0f1c3a0>, ...]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7fc4c22fbe50>, {'templates': [<django.template.base.Template...irst': False, 'last': True}, 'panel': <debug_toolbar.panels.profiling.ProfilingPanel object at 0x7fc4c073dcd0>}, {}]]})
signal_uid = 'template-render-140483017446848'
exception_uid = 'request-exception-140483017446848'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv/lib/python3.9/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c0767cd0>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv/lib/python3.9/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/term-late-else/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7fc4c0767a60>
request = <WSGIRequest: GET '/category/term-late-else/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv/lib/python3.9/site-packages/django/core/handlers/base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/term-late-else/'>
category_slug = 'term-late-else'

    def category_posts(request, category_slug):
        """View функция для страницы категорий."""
        try:
            category = Category.objects.get(slug=category_slug, is_published=True)
        except Category.DoesNotExist:
            raise Http404(f"Категория '{category_slug}' не найдена")
>       post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')

blogicum/blog/views.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.manager.Manager object at 0x7fc4c1838e50>, args = ()
kwargs = {'category': <Category: Home Stage Debate Indicate Decision Clearly>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def manager_method(self, *args, **kwargs):
>       return getattr(self.get_queryset(), name)(*args, **kwargs)

venv/lib/python3.9/site-packages/django/db/models/manager.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
args = ()
kwargs = {'category': <Category: Home Stage Debate Indicate Decision Clearly>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def filter(self, *args, **kwargs):
        """
        Return a new QuerySet instance with the args ANDed to the existing
        set.
        """
        self._not_support_combined_queries('filter')
>       return self._filter_or_exclude(False, args, kwargs)

venv/lib/python3.9/site-packages/django/db/models/query.py:941: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
negate = False, args = ()
kwargs = {'category': <Category: Home Stage Debate Indicate Decision Clearly>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def _filter_or_exclude(self, negate, args, kwargs):
        if args or kwargs:
            assert not self.query.is_sliced, \
                "Cannot filter a query once a slice has been taken."
    
        clone = self._chain()
        if self._defer_next_filter:
            self._defer_next_filter = False
            clone._deferred_filter = negate, args, kwargs
        else:
>           clone._filter_or_exclude_inplace(negate, args, kwargs)

venv/lib/python3.9/site-packages/django/db/models/query.py:961: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
negate = False, args = ()
kwargs = {'category': <Category: Home Stage Debate Indicate Decision Clearly>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def _filter_or_exclude_inplace(self, negate, args, kwargs):
        if negate:
            self._query.add_q(~Q(*args, **kwargs))
        else:
>           self._query.add_q(Q(*args, **kwargs))

venv/lib/python3.9/site-packages/django/db/models/query.py:968: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c0f1ce50>
q_object = <Q: (AND: ('category', <Category: Home Stage Debate Indicate Decision Clearly>), ('is_published', True), ('pub_date__lt', <function now at 0x7fc4c29e8d30>))>

    def add_q(self, q_object):
        """
        A preprocessor for the internal _add_q(). Responsible for doing final
        join promotion.
        """
        # For join promotion this case is doing an AND for the added q_object
        # and existing conditions. So, any existing inner join forces the join
        # type to remain inner. Existing outer joins can however be demoted.
        # (Consider case where rel_a is LOUTER and rel_a__col=1 is added - if
        # rel_a doesn't produce any rows, then the whole condition must fail.
        # So, demotion is OK.
        existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
>       clause, _ = self._add_q(q_object, self.used_aliases)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c0f1ce50>
q_object = <Q: (AND: ('category', <Category: Home Stage Debate Indicate Decision Clearly>), ('is_published', True), ('pub_date__lt', <function now at 0x7fc4c29e8d30>))>
used_aliases = {'blog_post'}, branch_negated = False, current_negated = False
allow_joins = True, split_subq = True, check_filterable = True

    def _add_q(self, q_object, used_aliases, branch_negated=False,
               current_negated=False, allow_joins=True, split_subq=True,
               check_filterable=True):
        """Add a Q-object to the current filter."""
        connector = q_object.connector
        current_negated = current_negated ^ q_object.negated
        branch_negated = branch_negated or q_object.negated
        target_clause = self.where_class(connector=connector,
                                         negated=q_object.negated)
        joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
        for child in q_object.children:
>           child_clause, needed_inner = self.build_filter(
                child, can_reuse=used_aliases, branch_negated=branch_negated,
                current_negated=current_negated, allow_joins=allow_joins,
                split_subq=split_subq, check_filterable=check_filterable,
            )

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1435: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c0f1ce50>
filter_expr = ('pub_date__lt', <function now at 0x7fc4c29e8d30>)
branch_negated = False, current_negated = False, can_reuse = {'blog_post'}
allow_joins = True, split_subq = True, reuse_with_filtered_relation = False
check_filterable = True

    def build_filter(self, filter_expr, branch_negated=False, current_negated=False,
                     can_reuse=None, allow_joins=True, split_subq=True,
                     reuse_with_filtered_relation=False, check_filterable=True):
        """
        Build a WhereNode for a single filter clause but don't add it
        to this Query. Query.add_q() will then add this filter to the where
        Node.
    
        The 'branch_negated' tells us if the current branch contains any
        negations. This will be used to determine if subqueries are needed.
    
        The 'current_negated' is used to determine if the current filter is
        negated or not and this will be used to determine if IS NULL filtering
        is needed.
    
        The difference between current_negated and branch_negated is that
        branch_negated is set on first negation, but current_negated is
        flipped for each negation.
    
        Note that add_filter will not do any negating itself, that is done
        upper in the code by add_q().
    
        The 'can_reuse' is a set of reusable joins for multijoins.
    
        If 'reuse_with_filtered_relation' is True, then only joins in can_reuse
        will be reused.
    
        The method will create a filter clause that can be added to the current
        query. However, if the filter isn't added to the query then the caller
        is responsible for unreffing the joins used.
        """
        if isinstance(filter_expr, dict):
            raise FieldError("Cannot parse keyword query as dict")
        if isinstance(filter_expr, Q):
            return self._add_q(
                filter_expr,
                branch_negated=branch_negated,
                current_negated=current_negated,
                used_aliases=can_reuse,
                allow_joins=allow_joins,
                split_subq=split_subq,
                check_filterable=check_filterable,
            )
        if hasattr(filter_expr, 'resolve_expression'):
            if not getattr(filter_expr, 'conditional', False):
                raise TypeError('Cannot filter against a non-conditional expression.')
            condition = self.build_lookup(
                ['exact'], filter_expr.resolve_expression(self, allow_joins=allow_joins), True
            )
            clause = self.where_class()
            clause.add(condition, AND)
            return clause, []
        arg, value = filter_expr
        if not arg:
            raise FieldError("Cannot parse keyword query %r" % arg)
        lookups, parts, reffed_expression = self.solve_lookup_type(arg)
    
        if check_filterable:
            self.check_filterable(reffed_expression)
    
        if not allow_joins and len(parts) > 1:
            raise FieldError("Joined field references are not permitted in this query")
    
        pre_joins = self.alias_refcount.copy()
        value = self.resolve_lookup_value(value, can_reuse, allow_joins)
        used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
    
        if check_filterable:
            self.check_filterable(value)
    
        clause = self.where_class()
        if reffed_expression:
            condition = self.build_lookup(lookups, reffed_expression, value)
            clause.add(condition, AND)
            return clause, []
    
        opts = self.get_meta()
        alias = self.get_initial_alias()
        allow_many = not branch_negated or not split_subq
    
        try:
            join_info = self.setup_joins(
                parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
                reuse_with_filtered_relation=reuse_with_filtered_relation,
            )
    
            # Prevent iterator from being consumed by check_related_objects()
            if isinstance(value, Iterator):
                value = list(value)
            self.check_related_objects(join_info.final_field, value, join_info.opts)
    
            # split_exclude() needs to know which joins were generated for the
            # lookup parts
            self._lookup_joins = join_info.joins
        except MultiJoin as e:
            return self.split_exclude(filter_expr, can_reuse, e.names_with_path)
    
        # Update used_joins before trimming since they are reused to determine
        # which joins could be later promoted to INNER.
        used_joins.update(join_info.joins)
        targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
        if can_reuse is not None:
            can_reuse.update(join_list)
    
        if join_info.final_field.is_relation:
            # No support for transforms for relational fields
            num_lookups = len(lookups)
            if num_lookups > 1:
                raise FieldError('Related Field got invalid lookup: {}'.format(lookups[0]))
            if len(targets) == 1:
                col = self._get_col(targets[0], join_info.final_field, alias)
            else:
                col = MultiColSource(alias, targets, join_info.targets, join_info.final_field)
        else:
            col = self._get_col(targets[0], join_info.final_field, alias)
    
>       condition = self.build_lookup(lookups, col, value)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c0f1ce50>
lookups = ['lt'], lhs = Col(blog_post, blog.Post.pub_date)
rhs = <function now at 0x7fc4c29e8d30>

    def build_lookup(self, lookups, lhs, rhs):
        """
        Try to extract transforms and lookup from given lhs.
    
        The lhs value is something that works like SQLExpression.
        The rhs value is what the lookup is going to compare against.
        The lookups is a list of names to extract using get_lookup()
        and get_transform().
        """
        # __exact is the default lookup if one isn't given.
        *transforms, lookup_name = lookups or ['exact']
        for name in transforms:
            lhs = self.try_transform(lhs, name)
        # First try get_lookup() so that the lookup takes precedence if the lhs
        # supports both transform and lookup for the name.
        lookup_class = lhs.get_lookup(lookup_name)
        if not lookup_class:
            if lhs.field.is_relation:
                raise FieldError('Related Field got invalid lookup: {}'.format(lookup_name))
            # A lookup wasn't found. Try to interpret the name as a transform
            # and do an Exact lookup against it.
            lhs = self.try_transform(lhs, lookup_name)
            lookup_name = 'exact'
            lookup_class = lhs.get_lookup(lookup_name)
            if not lookup_class:
                return
    
>       lookup = lookup_class(lhs, rhs)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1216: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.lookups.LessThan object at 0x7fc4c0f207f0>
lhs = Col(blog_post, blog.Post.pub_date), rhs = <function now at 0x7fc4c29e8d30>

    def __init__(self, lhs, rhs):
        self.lhs, self.rhs = lhs, rhs
>       self.rhs = self.get_prep_lookup()

venv/lib/python3.9/site-packages/django/db/models/lookups.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.lookups.LessThan object at 0x7fc4c0f207f0>

    def get_prep_lookup(self):
        if hasattr(self.rhs, 'resolve_expression'):
            return self.rhs
        if self.prepare_rhs and hasattr(self.lhs.output_field, 'get_prep_value'):
>           return self.lhs.output_field.get_prep_value(self.rhs)

venv/lib/python3.9/site-packages/django/db/models/lookups.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def get_prep_value(self, value):
>       value = super().get_prep_value(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1406: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def get_prep_value(self, value):
        value = super().get_prep_value(value)
>       return self.to_python(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def to_python(self, value):
        if value is None:
            return value
        if isinstance(value, datetime.datetime):
            return value
        if isinstance(value, datetime.date):
            value = datetime.datetime(value.year, value.month, value.day)
            if settings.USE_TZ:
                # For backwards compatibility, interpret naive datetimes in
                # local time. This won't work during DST change, but we can't
                # do much about it, so we let the exceptions percolate up the
                # call stack.
                warnings.warn("DateTimeField %s.%s received a naive datetime "
                              "(%s) while time zone support is active." %
                              (self.model.__name__, self.name, value),
                              RuntimeWarning)
                default_timezone = timezone.get_default_timezone()
                value = timezone.make_aware(value, default_timezone)
            return value
    
        try:
>           parsed = parse_datetime(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1367: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <function now at 0x7fc4c29e8d30>

    def parse_datetime(value):
        """Parse a string and return a datetime.datetime.
    
        This function supports time zone offsets. When the input contains one,
        the output uses a timezone with a fixed offset from UTC.
    
        Raise ValueError if the input is well formatted but not a valid datetime.
        Return None if the input isn't well formatted.
        """
>       match = datetime_re.match(value)
E       TypeError: expected string or bytes-like object

venv/lib/python3.9/site-packages/django/utils/dateparse.py:107: TypeError

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x7fc4c0767cd0>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)

tests/conftest.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_client = <django.test.client.Client object at 0x7fc4c0767cd0>
page_url = '/category/term-late-else/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests/conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x7fc4c0767cd0>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests/conftest.py:141: AssertionError
---------------------------- Captured stderr setup -----------------------------
Internal Server Error: /category/term-late-else/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
Internal Server Error: /category/term-late-else/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
------------------------------ Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /category/term-late-else/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
____________ ERROR at setup of test_category_page_posts_unpublished ____________

user_client = <django.test.client.Client object at 0x7fc4c0ed4940>
page_url = '/category/food-and-approach/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests/conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c0ed4940>
path = '/category/food-and-approach/', data = None, follow = False
secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv/lib/python3.9/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c0ed4940>
path = '/category/food-and-approach/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv/lib/python3.9/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c0ed4940>, method = 'GET'
path = '/category/food-and-approach/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/food-and-approach/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/food-and-approach/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv/lib/python3.9/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c0ed4940>
request = {'PATH_INFO': '/category/food-and-approach/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=9alk7w2xzxyvedjwsyn8k7ucj194dez2', 'PATH_INFO': '/category/food-and-approach/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'is_email': False, 'unicode_hint': '', 'frames': [{'exc_c...jango.template.base.Template object at 0x7fc4c0e617f0>, <django.template.base.Template object at 0x7fc4c0e617f0>, ...]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7fc4c22fbe50>, {'templates': [<django.template.base.Template...irst': False, 'last': True}, 'panel': <debug_toolbar.panels.profiling.ProfilingPanel object at 0x7fc4c0eb8b20>}, {}]]})
signal_uid = 'template-render-140483026788032'
exception_uid = 'request-exception-140483026788032'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv/lib/python3.9/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c0ed4940>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv/lib/python3.9/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/food-and-approach/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7fc4c0ed4a00>
request = <WSGIRequest: GET '/category/food-and-approach/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv/lib/python3.9/site-packages/django/core/handlers/base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/food-and-approach/'>
category_slug = 'food-and-approach'

    def category_posts(request, category_slug):
        """View функция для страницы категорий."""
        try:
            category = Category.objects.get(slug=category_slug, is_published=True)
        except Category.DoesNotExist:
            raise Http404(f"Категория '{category_slug}' не найдена")
>       post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')

blogicum/blog/views.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.manager.Manager object at 0x7fc4c1838e50>, args = ()
kwargs = {'category': <Category: Society Executive Suffer Program Buy Cultural>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def manager_method(self, *args, **kwargs):
>       return getattr(self.get_queryset(), name)(*args, **kwargs)

venv/lib/python3.9/site-packages/django/db/models/manager.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
args = ()
kwargs = {'category': <Category: Society Executive Suffer Program Buy Cultural>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def filter(self, *args, **kwargs):
        """
        Return a new QuerySet instance with the args ANDed to the existing
        set.
        """
        self._not_support_combined_queries('filter')
>       return self._filter_or_exclude(False, args, kwargs)

venv/lib/python3.9/site-packages/django/db/models/query.py:941: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
negate = False, args = ()
kwargs = {'category': <Category: Society Executive Suffer Program Buy Cultural>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def _filter_or_exclude(self, negate, args, kwargs):
        if args or kwargs:
            assert not self.query.is_sliced, \
                "Cannot filter a query once a slice has been taken."
    
        clone = self._chain()
        if self._defer_next_filter:
            self._defer_next_filter = False
            clone._deferred_filter = negate, args, kwargs
        else:
>           clone._filter_or_exclude_inplace(negate, args, kwargs)

venv/lib/python3.9/site-packages/django/db/models/query.py:961: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
negate = False, args = ()
kwargs = {'category': <Category: Society Executive Suffer Program Buy Cultural>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def _filter_or_exclude_inplace(self, negate, args, kwargs):
        if negate:
            self._query.add_q(~Q(*args, **kwargs))
        else:
>           self._query.add_q(Q(*args, **kwargs))

venv/lib/python3.9/site-packages/django/db/models/query.py:968: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c0e61850>
q_object = <Q: (AND: ('category', <Category: Society Executive Suffer Program Buy Cultural>), ('is_published', True), ('pub_date__lt', <function now at 0x7fc4c29e8d30>))>

    def add_q(self, q_object):
        """
        A preprocessor for the internal _add_q(). Responsible for doing final
        join promotion.
        """
        # For join promotion this case is doing an AND for the added q_object
        # and existing conditions. So, any existing inner join forces the join
        # type to remain inner. Existing outer joins can however be demoted.
        # (Consider case where rel_a is LOUTER and rel_a__col=1 is added - if
        # rel_a doesn't produce any rows, then the whole condition must fail.
        # So, demotion is OK.
        existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
>       clause, _ = self._add_q(q_object, self.used_aliases)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c0e61850>
q_object = <Q: (AND: ('category', <Category: Society Executive Suffer Program Buy Cultural>), ('is_published', True), ('pub_date__lt', <function now at 0x7fc4c29e8d30>))>
used_aliases = {'blog_post'}, branch_negated = False, current_negated = False
allow_joins = True, split_subq = True, check_filterable = True

    def _add_q(self, q_object, used_aliases, branch_negated=False,
               current_negated=False, allow_joins=True, split_subq=True,
               check_filterable=True):
        """Add a Q-object to the current filter."""
        connector = q_object.connector
        current_negated = current_negated ^ q_object.negated
        branch_negated = branch_negated or q_object.negated
        target_clause = self.where_class(connector=connector,
                                         negated=q_object.negated)
        joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
        for child in q_object.children:
>           child_clause, needed_inner = self.build_filter(
                child, can_reuse=used_aliases, branch_negated=branch_negated,
                current_negated=current_negated, allow_joins=allow_joins,
                split_subq=split_subq, check_filterable=check_filterable,
            )

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1435: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c0e61850>
filter_expr = ('pub_date__lt', <function now at 0x7fc4c29e8d30>)
branch_negated = False, current_negated = False, can_reuse = {'blog_post'}
allow_joins = True, split_subq = True, reuse_with_filtered_relation = False
check_filterable = True

    def build_filter(self, filter_expr, branch_negated=False, current_negated=False,
                     can_reuse=None, allow_joins=True, split_subq=True,
                     reuse_with_filtered_relation=False, check_filterable=True):
        """
        Build a WhereNode for a single filter clause but don't add it
        to this Query. Query.add_q() will then add this filter to the where
        Node.
    
        The 'branch_negated' tells us if the current branch contains any
        negations. This will be used to determine if subqueries are needed.
    
        The 'current_negated' is used to determine if the current filter is
        negated or not and this will be used to determine if IS NULL filtering
        is needed.
    
        The difference between current_negated and branch_negated is that
        branch_negated is set on first negation, but current_negated is
        flipped for each negation.
    
        Note that add_filter will not do any negating itself, that is done
        upper in the code by add_q().
    
        The 'can_reuse' is a set of reusable joins for multijoins.
    
        If 'reuse_with_filtered_relation' is True, then only joins in can_reuse
        will be reused.
    
        The method will create a filter clause that can be added to the current
        query. However, if the filter isn't added to the query then the caller
        is responsible for unreffing the joins used.
        """
        if isinstance(filter_expr, dict):
            raise FieldError("Cannot parse keyword query as dict")
        if isinstance(filter_expr, Q):
            return self._add_q(
                filter_expr,
                branch_negated=branch_negated,
                current_negated=current_negated,
                used_aliases=can_reuse,
                allow_joins=allow_joins,
                split_subq=split_subq,
                check_filterable=check_filterable,
            )
        if hasattr(filter_expr, 'resolve_expression'):
            if not getattr(filter_expr, 'conditional', False):
                raise TypeError('Cannot filter against a non-conditional expression.')
            condition = self.build_lookup(
                ['exact'], filter_expr.resolve_expression(self, allow_joins=allow_joins), True
            )
            clause = self.where_class()
            clause.add(condition, AND)
            return clause, []
        arg, value = filter_expr
        if not arg:
            raise FieldError("Cannot parse keyword query %r" % arg)
        lookups, parts, reffed_expression = self.solve_lookup_type(arg)
    
        if check_filterable:
            self.check_filterable(reffed_expression)
    
        if not allow_joins and len(parts) > 1:
            raise FieldError("Joined field references are not permitted in this query")
    
        pre_joins = self.alias_refcount.copy()
        value = self.resolve_lookup_value(value, can_reuse, allow_joins)
        used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
    
        if check_filterable:
            self.check_filterable(value)
    
        clause = self.where_class()
        if reffed_expression:
            condition = self.build_lookup(lookups, reffed_expression, value)
            clause.add(condition, AND)
            return clause, []
    
        opts = self.get_meta()
        alias = self.get_initial_alias()
        allow_many = not branch_negated or not split_subq
    
        try:
            join_info = self.setup_joins(
                parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
                reuse_with_filtered_relation=reuse_with_filtered_relation,
            )
    
            # Prevent iterator from being consumed by check_related_objects()
            if isinstance(value, Iterator):
                value = list(value)
            self.check_related_objects(join_info.final_field, value, join_info.opts)
    
            # split_exclude() needs to know which joins were generated for the
            # lookup parts
            self._lookup_joins = join_info.joins
        except MultiJoin as e:
            return self.split_exclude(filter_expr, can_reuse, e.names_with_path)
    
        # Update used_joins before trimming since they are reused to determine
        # which joins could be later promoted to INNER.
        used_joins.update(join_info.joins)
        targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
        if can_reuse is not None:
            can_reuse.update(join_list)
    
        if join_info.final_field.is_relation:
            # No support for transforms for relational fields
            num_lookups = len(lookups)
            if num_lookups > 1:
                raise FieldError('Related Field got invalid lookup: {}'.format(lookups[0]))
            if len(targets) == 1:
                col = self._get_col(targets[0], join_info.final_field, alias)
            else:
                col = MultiColSource(alias, targets, join_info.targets, join_info.final_field)
        else:
            col = self._get_col(targets[0], join_info.final_field, alias)
    
>       condition = self.build_lookup(lookups, col, value)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c0e61850>
lookups = ['lt'], lhs = Col(blog_post, blog.Post.pub_date)
rhs = <function now at 0x7fc4c29e8d30>

    def build_lookup(self, lookups, lhs, rhs):
        """
        Try to extract transforms and lookup from given lhs.
    
        The lhs value is something that works like SQLExpression.
        The rhs value is what the lookup is going to compare against.
        The lookups is a list of names to extract using get_lookup()
        and get_transform().
        """
        # __exact is the default lookup if one isn't given.
        *transforms, lookup_name = lookups or ['exact']
        for name in transforms:
            lhs = self.try_transform(lhs, name)
        # First try get_lookup() so that the lookup takes precedence if the lhs
        # supports both transform and lookup for the name.
        lookup_class = lhs.get_lookup(lookup_name)
        if not lookup_class:
            if lhs.field.is_relation:
                raise FieldError('Related Field got invalid lookup: {}'.format(lookup_name))
            # A lookup wasn't found. Try to interpret the name as a transform
            # and do an Exact lookup against it.
            lhs = self.try_transform(lhs, lookup_name)
            lookup_name = 'exact'
            lookup_class = lhs.get_lookup(lookup_name)
            if not lookup_class:
                return
    
>       lookup = lookup_class(lhs, rhs)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1216: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.lookups.LessThan object at 0x7fc4c0e5f370>
lhs = Col(blog_post, blog.Post.pub_date), rhs = <function now at 0x7fc4c29e8d30>

    def __init__(self, lhs, rhs):
        self.lhs, self.rhs = lhs, rhs
>       self.rhs = self.get_prep_lookup()

venv/lib/python3.9/site-packages/django/db/models/lookups.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.lookups.LessThan object at 0x7fc4c0e5f370>

    def get_prep_lookup(self):
        if hasattr(self.rhs, 'resolve_expression'):
            return self.rhs
        if self.prepare_rhs and hasattr(self.lhs.output_field, 'get_prep_value'):
>           return self.lhs.output_field.get_prep_value(self.rhs)

venv/lib/python3.9/site-packages/django/db/models/lookups.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def get_prep_value(self, value):
>       value = super().get_prep_value(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1406: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def get_prep_value(self, value):
        value = super().get_prep_value(value)
>       return self.to_python(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def to_python(self, value):
        if value is None:
            return value
        if isinstance(value, datetime.datetime):
            return value
        if isinstance(value, datetime.date):
            value = datetime.datetime(value.year, value.month, value.day)
            if settings.USE_TZ:
                # For backwards compatibility, interpret naive datetimes in
                # local time. This won't work during DST change, but we can't
                # do much about it, so we let the exceptions percolate up the
                # call stack.
                warnings.warn("DateTimeField %s.%s received a naive datetime "
                              "(%s) while time zone support is active." %
                              (self.model.__name__, self.name, value),
                              RuntimeWarning)
                default_timezone = timezone.get_default_timezone()
                value = timezone.make_aware(value, default_timezone)
            return value
    
        try:
>           parsed = parse_datetime(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1367: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <function now at 0x7fc4c29e8d30>

    def parse_datetime(value):
        """Parse a string and return a datetime.datetime.
    
        This function supports time zone offsets. When the input contains one,
        the output uses a timezone with a fixed offset from UTC.
    
        Raise ValueError if the input is well formatted but not a valid datetime.
        Return None if the input isn't well formatted.
        """
>       match = datetime_re.match(value)
E       TypeError: expected string or bytes-like object

venv/lib/python3.9/site-packages/django/utils/dateparse.py:107: TypeError

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x7fc4c0ed4940>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)

tests/conftest.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_client = <django.test.client.Client object at 0x7fc4c0ed4940>
page_url = '/category/food-and-approach/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests/conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x7fc4c0ed4940>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests/conftest.py:141: AssertionError
---------------------------- Captured stderr setup -----------------------------
Internal Server Error: /category/food-and-approach/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
Internal Server Error: /category/food-and-approach/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
------------------------------ Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /category/food-and-approach/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
__________ ERROR at setup of test_category_page_pub_date_later_today ___________

user_client = <django.test.client.Client object at 0x7fc4c10514c0>
page_url = '/category/stock-professor/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests/conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c10514c0>
path = '/category/stock-professor/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv/lib/python3.9/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c10514c0>
path = '/category/stock-professor/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv/lib/python3.9/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c10514c0>, method = 'GET'
path = '/category/stock-professor/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/stock-professor/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/stock-professor/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv/lib/python3.9/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c10514c0>
request = {'PATH_INFO': '/category/stock-professor/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=cfsqwzwv2plipe1bsh0nkyxh9r12rhiw', 'PATH_INFO': '/category/stock-professor/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'is_email': False, 'unicode_hint': '', 'frames': [{'exc_c...jango.template.base.Template object at 0x7fc4c1037580>, <django.template.base.Template object at 0x7fc4c1037580>, ...]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7fc4c22fbe50>, {'templates': [<django.template.base.Template...irst': False, 'last': True}, 'panel': <debug_toolbar.panels.profiling.ProfilingPanel object at 0x7fc4c03d6610>}, {}]]})
signal_uid = 'template-render-140483017448384'
exception_uid = 'request-exception-140483017448384'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv/lib/python3.9/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c10514c0>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv/lib/python3.9/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/stock-professor/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7fc4c1051430>
request = <WSGIRequest: GET '/category/stock-professor/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv/lib/python3.9/site-packages/django/core/handlers/base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/stock-professor/'>
category_slug = 'stock-professor'

    def category_posts(request, category_slug):
        """View функция для страницы категорий."""
        try:
            category = Category.objects.get(slug=category_slug, is_published=True)
        except Category.DoesNotExist:
            raise Http404(f"Категория '{category_slug}' не найдена")
>       post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')

blogicum/blog/views.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.manager.Manager object at 0x7fc4c1838e50>, args = ()
kwargs = {'category': <Category: Red Baby Property Already Knowledge Later>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def manager_method(self, *args, **kwargs):
>       return getattr(self.get_queryset(), name)(*args, **kwargs)

venv/lib/python3.9/site-packages/django/db/models/manager.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
args = ()
kwargs = {'category': <Category: Red Baby Property Already Knowledge Later>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def filter(self, *args, **kwargs):
        """
        Return a new QuerySet instance with the args ANDed to the existing
        set.
        """
        self._not_support_combined_queries('filter')
>       return self._filter_or_exclude(False, args, kwargs)

venv/lib/python3.9/site-packages/django/db/models/query.py:941: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
negate = False, args = ()
kwargs = {'category': <Category: Red Baby Property Already Knowledge Later>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def _filter_or_exclude(self, negate, args, kwargs):
        if args or kwargs:
            assert not self.query.is_sliced, \
                "Cannot filter a query once a slice has been taken."
    
        clone = self._chain()
        if self._defer_next_filter:
            self._defer_next_filter = False
            clone._deferred_filter = negate, args, kwargs
        else:
>           clone._filter_or_exclude_inplace(negate, args, kwargs)

venv/lib/python3.9/site-packages/django/db/models/query.py:961: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
negate = False, args = ()
kwargs = {'category': <Category: Red Baby Property Already Knowledge Later>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def _filter_or_exclude_inplace(self, negate, args, kwargs):
        if negate:
            self._query.add_q(~Q(*args, **kwargs))
        else:
>           self._query.add_q(Q(*args, **kwargs))

venv/lib/python3.9/site-packages/django/db/models/query.py:968: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c1037a60>
q_object = <Q: (AND: ('category', <Category: Red Baby Property Already Knowledge Later>), ('is_published', True), ('pub_date__lt', <function now at 0x7fc4c29e8d30>))>

    def add_q(self, q_object):
        """
        A preprocessor for the internal _add_q(). Responsible for doing final
        join promotion.
        """
        # For join promotion this case is doing an AND for the added q_object
        # and existing conditions. So, any existing inner join forces the join
        # type to remain inner. Existing outer joins can however be demoted.
        # (Consider case where rel_a is LOUTER and rel_a__col=1 is added - if
        # rel_a doesn't produce any rows, then the whole condition must fail.
        # So, demotion is OK.
        existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
>       clause, _ = self._add_q(q_object, self.used_aliases)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c1037a60>
q_object = <Q: (AND: ('category', <Category: Red Baby Property Already Knowledge Later>), ('is_published', True), ('pub_date__lt', <function now at 0x7fc4c29e8d30>))>
used_aliases = {'blog_post'}, branch_negated = False, current_negated = False
allow_joins = True, split_subq = True, check_filterable = True

    def _add_q(self, q_object, used_aliases, branch_negated=False,
               current_negated=False, allow_joins=True, split_subq=True,
               check_filterable=True):
        """Add a Q-object to the current filter."""
        connector = q_object.connector
        current_negated = current_negated ^ q_object.negated
        branch_negated = branch_negated or q_object.negated
        target_clause = self.where_class(connector=connector,
                                         negated=q_object.negated)
        joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
        for child in q_object.children:
>           child_clause, needed_inner = self.build_filter(
                child, can_reuse=used_aliases, branch_negated=branch_negated,
                current_negated=current_negated, allow_joins=allow_joins,
                split_subq=split_subq, check_filterable=check_filterable,
            )

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1435: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c1037a60>
filter_expr = ('pub_date__lt', <function now at 0x7fc4c29e8d30>)
branch_negated = False, current_negated = False, can_reuse = {'blog_post'}
allow_joins = True, split_subq = True, reuse_with_filtered_relation = False
check_filterable = True

    def build_filter(self, filter_expr, branch_negated=False, current_negated=False,
                     can_reuse=None, allow_joins=True, split_subq=True,
                     reuse_with_filtered_relation=False, check_filterable=True):
        """
        Build a WhereNode for a single filter clause but don't add it
        to this Query. Query.add_q() will then add this filter to the where
        Node.
    
        The 'branch_negated' tells us if the current branch contains any
        negations. This will be used to determine if subqueries are needed.
    
        The 'current_negated' is used to determine if the current filter is
        negated or not and this will be used to determine if IS NULL filtering
        is needed.
    
        The difference between current_negated and branch_negated is that
        branch_negated is set on first negation, but current_negated is
        flipped for each negation.
    
        Note that add_filter will not do any negating itself, that is done
        upper in the code by add_q().
    
        The 'can_reuse' is a set of reusable joins for multijoins.
    
        If 'reuse_with_filtered_relation' is True, then only joins in can_reuse
        will be reused.
    
        The method will create a filter clause that can be added to the current
        query. However, if the filter isn't added to the query then the caller
        is responsible for unreffing the joins used.
        """
        if isinstance(filter_expr, dict):
            raise FieldError("Cannot parse keyword query as dict")
        if isinstance(filter_expr, Q):
            return self._add_q(
                filter_expr,
                branch_negated=branch_negated,
                current_negated=current_negated,
                used_aliases=can_reuse,
                allow_joins=allow_joins,
                split_subq=split_subq,
                check_filterable=check_filterable,
            )
        if hasattr(filter_expr, 'resolve_expression'):
            if not getattr(filter_expr, 'conditional', False):
                raise TypeError('Cannot filter against a non-conditional expression.')
            condition = self.build_lookup(
                ['exact'], filter_expr.resolve_expression(self, allow_joins=allow_joins), True
            )
            clause = self.where_class()
            clause.add(condition, AND)
            return clause, []
        arg, value = filter_expr
        if not arg:
            raise FieldError("Cannot parse keyword query %r" % arg)
        lookups, parts, reffed_expression = self.solve_lookup_type(arg)
    
        if check_filterable:
            self.check_filterable(reffed_expression)
    
        if not allow_joins and len(parts) > 1:
            raise FieldError("Joined field references are not permitted in this query")
    
        pre_joins = self.alias_refcount.copy()
        value = self.resolve_lookup_value(value, can_reuse, allow_joins)
        used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
    
        if check_filterable:
            self.check_filterable(value)
    
        clause = self.where_class()
        if reffed_expression:
            condition = self.build_lookup(lookups, reffed_expression, value)
            clause.add(condition, AND)
            return clause, []
    
        opts = self.get_meta()
        alias = self.get_initial_alias()
        allow_many = not branch_negated or not split_subq
    
        try:
            join_info = self.setup_joins(
                parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
                reuse_with_filtered_relation=reuse_with_filtered_relation,
            )
    
            # Prevent iterator from being consumed by check_related_objects()
            if isinstance(value, Iterator):
                value = list(value)
            self.check_related_objects(join_info.final_field, value, join_info.opts)
    
            # split_exclude() needs to know which joins were generated for the
            # lookup parts
            self._lookup_joins = join_info.joins
        except MultiJoin as e:
            return self.split_exclude(filter_expr, can_reuse, e.names_with_path)
    
        # Update used_joins before trimming since they are reused to determine
        # which joins could be later promoted to INNER.
        used_joins.update(join_info.joins)
        targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
        if can_reuse is not None:
            can_reuse.update(join_list)
    
        if join_info.final_field.is_relation:
            # No support for transforms for relational fields
            num_lookups = len(lookups)
            if num_lookups > 1:
                raise FieldError('Related Field got invalid lookup: {}'.format(lookups[0]))
            if len(targets) == 1:
                col = self._get_col(targets[0], join_info.final_field, alias)
            else:
                col = MultiColSource(alias, targets, join_info.targets, join_info.final_field)
        else:
            col = self._get_col(targets[0], join_info.final_field, alias)
    
>       condition = self.build_lookup(lookups, col, value)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c1037a60>
lookups = ['lt'], lhs = Col(blog_post, blog.Post.pub_date)
rhs = <function now at 0x7fc4c29e8d30>

    def build_lookup(self, lookups, lhs, rhs):
        """
        Try to extract transforms and lookup from given lhs.
    
        The lhs value is something that works like SQLExpression.
        The rhs value is what the lookup is going to compare against.
        The lookups is a list of names to extract using get_lookup()
        and get_transform().
        """
        # __exact is the default lookup if one isn't given.
        *transforms, lookup_name = lookups or ['exact']
        for name in transforms:
            lhs = self.try_transform(lhs, name)
        # First try get_lookup() so that the lookup takes precedence if the lhs
        # supports both transform and lookup for the name.
        lookup_class = lhs.get_lookup(lookup_name)
        if not lookup_class:
            if lhs.field.is_relation:
                raise FieldError('Related Field got invalid lookup: {}'.format(lookup_name))
            # A lookup wasn't found. Try to interpret the name as a transform
            # and do an Exact lookup against it.
            lhs = self.try_transform(lhs, lookup_name)
            lookup_name = 'exact'
            lookup_class = lhs.get_lookup(lookup_name)
            if not lookup_class:
                return
    
>       lookup = lookup_class(lhs, rhs)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1216: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.lookups.LessThan object at 0x7fc4c03cc3d0>
lhs = Col(blog_post, blog.Post.pub_date), rhs = <function now at 0x7fc4c29e8d30>

    def __init__(self, lhs, rhs):
        self.lhs, self.rhs = lhs, rhs
>       self.rhs = self.get_prep_lookup()

venv/lib/python3.9/site-packages/django/db/models/lookups.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.lookups.LessThan object at 0x7fc4c03cc3d0>

    def get_prep_lookup(self):
        if hasattr(self.rhs, 'resolve_expression'):
            return self.rhs
        if self.prepare_rhs and hasattr(self.lhs.output_field, 'get_prep_value'):
>           return self.lhs.output_field.get_prep_value(self.rhs)

venv/lib/python3.9/site-packages/django/db/models/lookups.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def get_prep_value(self, value):
>       value = super().get_prep_value(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1406: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def get_prep_value(self, value):
        value = super().get_prep_value(value)
>       return self.to_python(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def to_python(self, value):
        if value is None:
            return value
        if isinstance(value, datetime.datetime):
            return value
        if isinstance(value, datetime.date):
            value = datetime.datetime(value.year, value.month, value.day)
            if settings.USE_TZ:
                # For backwards compatibility, interpret naive datetimes in
                # local time. This won't work during DST change, but we can't
                # do much about it, so we let the exceptions percolate up the
                # call stack.
                warnings.warn("DateTimeField %s.%s received a naive datetime "
                              "(%s) while time zone support is active." %
                              (self.model.__name__, self.name, value),
                              RuntimeWarning)
                default_timezone = timezone.get_default_timezone()
                value = timezone.make_aware(value, default_timezone)
            return value
    
        try:
>           parsed = parse_datetime(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1367: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <function now at 0x7fc4c29e8d30>

    def parse_datetime(value):
        """Parse a string and return a datetime.datetime.
    
        This function supports time zone offsets. When the input contains one,
        the output uses a timezone with a fixed offset from UTC.
    
        Raise ValueError if the input is well formatted but not a valid datetime.
        Return None if the input isn't well formatted.
        """
>       match = datetime_re.match(value)
E       TypeError: expected string or bytes-like object

venv/lib/python3.9/site-packages/django/utils/dateparse.py:107: TypeError

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x7fc4c10514c0>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)

tests/conftest.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_client = <django.test.client.Client object at 0x7fc4c10514c0>
page_url = '/category/stock-professor/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests/conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x7fc4c10514c0>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests/conftest.py:141: AssertionError
---------------------------- Captured stderr setup -----------------------------
Internal Server Error: /category/stock-professor/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
Internal Server Error: /category/stock-professor/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
------------------------------ Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /category/stock-professor/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
___________ ERROR at setup of test_category_page_posts_with_location ___________

user_client = <django.test.client.Client object at 0x7fc4c111bca0>
page_url = '/category/certain-these/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests/conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c111bca0>
path = '/category/certain-these/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv/lib/python3.9/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c111bca0>
path = '/category/certain-these/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv/lib/python3.9/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c111bca0>, method = 'GET'
path = '/category/certain-these/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/certain-these/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/certain-these/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv/lib/python3.9/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c111bca0>
request = {'PATH_INFO': '/category/certain-these/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=05yqojy88tt442d1d9q3wujc9pzftddl', 'PATH_INFO': '/category/certain-these/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'is_email': False, 'unicode_hint': '', 'frames': [{'exc_c...jango.template.base.Template object at 0x7fc4c1130850>, <django.template.base.Template object at 0x7fc4c1130850>, ...]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7fc4c22fbe50>, {'templates': [<django.template.base.Template...irst': False, 'last': True}, 'panel': <debug_toolbar.panels.profiling.ProfilingPanel object at 0x7fc4c1147d00>}, {}]]})
signal_uid = 'template-render-140483031786496'
exception_uid = 'request-exception-140483031786496'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv/lib/python3.9/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4c111bca0>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv/lib/python3.9/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/certain-these/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7fc4c111bb20>
request = <WSGIRequest: GET '/category/certain-these/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv/lib/python3.9/site-packages/django/core/handlers/base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/certain-these/'>
category_slug = 'certain-these'

    def category_posts(request, category_slug):
        """View функция для страницы категорий."""
        try:
            category = Category.objects.get(slug=category_slug, is_published=True)
        except Category.DoesNotExist:
            raise Http404(f"Категория '{category_slug}' не найдена")
>       post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')

blogicum/blog/views.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.manager.Manager object at 0x7fc4c1838e50>, args = ()
kwargs = {'category': <Category: Manager Window If Center Stop Dinner>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def manager_method(self, *args, **kwargs):
>       return getattr(self.get_queryset(), name)(*args, **kwargs)

venv/lib/python3.9/site-packages/django/db/models/manager.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
args = ()
kwargs = {'category': <Category: Manager Window If Center Stop Dinner>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def filter(self, *args, **kwargs):
        """
        Return a new QuerySet instance with the args ANDed to the existing
        set.
        """
        self._not_support_combined_queries('filter')
>       return self._filter_or_exclude(False, args, kwargs)

venv/lib/python3.9/site-packages/django/db/models/query.py:941: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
negate = False, args = ()
kwargs = {'category': <Category: Manager Window If Center Stop Dinner>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def _filter_or_exclude(self, negate, args, kwargs):
        if args or kwargs:
            assert not self.query.is_sliced, \
                "Cannot filter a query once a slice has been taken."
    
        clone = self._chain()
        if self._defer_next_filter:
            self._defer_next_filter = False
            clone._deferred_filter = negate, args, kwargs
        else:
>           clone._filter_or_exclude_inplace(negate, args, kwargs)

venv/lib/python3.9/site-packages/django/db/models/query.py:961: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
negate = False, args = ()
kwargs = {'category': <Category: Manager Window If Center Stop Dinner>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def _filter_or_exclude_inplace(self, negate, args, kwargs):
        if negate:
            self._query.add_q(~Q(*args, **kwargs))
        else:
>           self._query.add_q(Q(*args, **kwargs))

venv/lib/python3.9/site-packages/django/db/models/query.py:968: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c1135130>
q_object = <Q: (AND: ('category', <Category: Manager Window If Center Stop Dinner>), ('is_published', True), ('pub_date__lt', <function now at 0x7fc4c29e8d30>))>

    def add_q(self, q_object):
        """
        A preprocessor for the internal _add_q(). Responsible for doing final
        join promotion.
        """
        # For join promotion this case is doing an AND for the added q_object
        # and existing conditions. So, any existing inner join forces the join
        # type to remain inner. Existing outer joins can however be demoted.
        # (Consider case where rel_a is LOUTER and rel_a__col=1 is added - if
        # rel_a doesn't produce any rows, then the whole condition must fail.
        # So, demotion is OK.
        existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
>       clause, _ = self._add_q(q_object, self.used_aliases)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c1135130>
q_object = <Q: (AND: ('category', <Category: Manager Window If Center Stop Dinner>), ('is_published', True), ('pub_date__lt', <function now at 0x7fc4c29e8d30>))>
used_aliases = {'blog_post'}, branch_negated = False, current_negated = False
allow_joins = True, split_subq = True, check_filterable = True

    def _add_q(self, q_object, used_aliases, branch_negated=False,
               current_negated=False, allow_joins=True, split_subq=True,
               check_filterable=True):
        """Add a Q-object to the current filter."""
        connector = q_object.connector
        current_negated = current_negated ^ q_object.negated
        branch_negated = branch_negated or q_object.negated
        target_clause = self.where_class(connector=connector,
                                         negated=q_object.negated)
        joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
        for child in q_object.children:
>           child_clause, needed_inner = self.build_filter(
                child, can_reuse=used_aliases, branch_negated=branch_negated,
                current_negated=current_negated, allow_joins=allow_joins,
                split_subq=split_subq, check_filterable=check_filterable,
            )

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1435: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c1135130>
filter_expr = ('pub_date__lt', <function now at 0x7fc4c29e8d30>)
branch_negated = False, current_negated = False, can_reuse = {'blog_post'}
allow_joins = True, split_subq = True, reuse_with_filtered_relation = False
check_filterable = True

    def build_filter(self, filter_expr, branch_negated=False, current_negated=False,
                     can_reuse=None, allow_joins=True, split_subq=True,
                     reuse_with_filtered_relation=False, check_filterable=True):
        """
        Build a WhereNode for a single filter clause but don't add it
        to this Query. Query.add_q() will then add this filter to the where
        Node.
    
        The 'branch_negated' tells us if the current branch contains any
        negations. This will be used to determine if subqueries are needed.
    
        The 'current_negated' is used to determine if the current filter is
        negated or not and this will be used to determine if IS NULL filtering
        is needed.
    
        The difference between current_negated and branch_negated is that
        branch_negated is set on first negation, but current_negated is
        flipped for each negation.
    
        Note that add_filter will not do any negating itself, that is done
        upper in the code by add_q().
    
        The 'can_reuse' is a set of reusable joins for multijoins.
    
        If 'reuse_with_filtered_relation' is True, then only joins in can_reuse
        will be reused.
    
        The method will create a filter clause that can be added to the current
        query. However, if the filter isn't added to the query then the caller
        is responsible for unreffing the joins used.
        """
        if isinstance(filter_expr, dict):
            raise FieldError("Cannot parse keyword query as dict")
        if isinstance(filter_expr, Q):
            return self._add_q(
                filter_expr,
                branch_negated=branch_negated,
                current_negated=current_negated,
                used_aliases=can_reuse,
                allow_joins=allow_joins,
                split_subq=split_subq,
                check_filterable=check_filterable,
            )
        if hasattr(filter_expr, 'resolve_expression'):
            if not getattr(filter_expr, 'conditional', False):
                raise TypeError('Cannot filter against a non-conditional expression.')
            condition = self.build_lookup(
                ['exact'], filter_expr.resolve_expression(self, allow_joins=allow_joins), True
            )
            clause = self.where_class()
            clause.add(condition, AND)
            return clause, []
        arg, value = filter_expr
        if not arg:
            raise FieldError("Cannot parse keyword query %r" % arg)
        lookups, parts, reffed_expression = self.solve_lookup_type(arg)
    
        if check_filterable:
            self.check_filterable(reffed_expression)
    
        if not allow_joins and len(parts) > 1:
            raise FieldError("Joined field references are not permitted in this query")
    
        pre_joins = self.alias_refcount.copy()
        value = self.resolve_lookup_value(value, can_reuse, allow_joins)
        used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
    
        if check_filterable:
            self.check_filterable(value)
    
        clause = self.where_class()
        if reffed_expression:
            condition = self.build_lookup(lookups, reffed_expression, value)
            clause.add(condition, AND)
            return clause, []
    
        opts = self.get_meta()
        alias = self.get_initial_alias()
        allow_many = not branch_negated or not split_subq
    
        try:
            join_info = self.setup_joins(
                parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
                reuse_with_filtered_relation=reuse_with_filtered_relation,
            )
    
            # Prevent iterator from being consumed by check_related_objects()
            if isinstance(value, Iterator):
                value = list(value)
            self.check_related_objects(join_info.final_field, value, join_info.opts)
    
            # split_exclude() needs to know which joins were generated for the
            # lookup parts
            self._lookup_joins = join_info.joins
        except MultiJoin as e:
            return self.split_exclude(filter_expr, can_reuse, e.names_with_path)
    
        # Update used_joins before trimming since they are reused to determine
        # which joins could be later promoted to INNER.
        used_joins.update(join_info.joins)
        targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
        if can_reuse is not None:
            can_reuse.update(join_list)
    
        if join_info.final_field.is_relation:
            # No support for transforms for relational fields
            num_lookups = len(lookups)
            if num_lookups > 1:
                raise FieldError('Related Field got invalid lookup: {}'.format(lookups[0]))
            if len(targets) == 1:
                col = self._get_col(targets[0], join_info.final_field, alias)
            else:
                col = MultiColSource(alias, targets, join_info.targets, join_info.final_field)
        else:
            col = self._get_col(targets[0], join_info.final_field, alias)
    
>       condition = self.build_lookup(lookups, col, value)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c1135130>
lookups = ['lt'], lhs = Col(blog_post, blog.Post.pub_date)
rhs = <function now at 0x7fc4c29e8d30>

    def build_lookup(self, lookups, lhs, rhs):
        """
        Try to extract transforms and lookup from given lhs.
    
        The lhs value is something that works like SQLExpression.
        The rhs value is what the lookup is going to compare against.
        The lookups is a list of names to extract using get_lookup()
        and get_transform().
        """
        # __exact is the default lookup if one isn't given.
        *transforms, lookup_name = lookups or ['exact']
        for name in transforms:
            lhs = self.try_transform(lhs, name)
        # First try get_lookup() so that the lookup takes precedence if the lhs
        # supports both transform and lookup for the name.
        lookup_class = lhs.get_lookup(lookup_name)
        if not lookup_class:
            if lhs.field.is_relation:
                raise FieldError('Related Field got invalid lookup: {}'.format(lookup_name))
            # A lookup wasn't found. Try to interpret the name as a transform
            # and do an Exact lookup against it.
            lhs = self.try_transform(lhs, lookup_name)
            lookup_name = 'exact'
            lookup_class = lhs.get_lookup(lookup_name)
            if not lookup_class:
                return
    
>       lookup = lookup_class(lhs, rhs)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1216: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.lookups.LessThan object at 0x7fc4c11359d0>
lhs = Col(blog_post, blog.Post.pub_date), rhs = <function now at 0x7fc4c29e8d30>

    def __init__(self, lhs, rhs):
        self.lhs, self.rhs = lhs, rhs
>       self.rhs = self.get_prep_lookup()

venv/lib/python3.9/site-packages/django/db/models/lookups.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.lookups.LessThan object at 0x7fc4c11359d0>

    def get_prep_lookup(self):
        if hasattr(self.rhs, 'resolve_expression'):
            return self.rhs
        if self.prepare_rhs and hasattr(self.lhs.output_field, 'get_prep_value'):
>           return self.lhs.output_field.get_prep_value(self.rhs)

venv/lib/python3.9/site-packages/django/db/models/lookups.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def get_prep_value(self, value):
>       value = super().get_prep_value(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1406: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def get_prep_value(self, value):
        value = super().get_prep_value(value)
>       return self.to_python(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def to_python(self, value):
        if value is None:
            return value
        if isinstance(value, datetime.datetime):
            return value
        if isinstance(value, datetime.date):
            value = datetime.datetime(value.year, value.month, value.day)
            if settings.USE_TZ:
                # For backwards compatibility, interpret naive datetimes in
                # local time. This won't work during DST change, but we can't
                # do much about it, so we let the exceptions percolate up the
                # call stack.
                warnings.warn("DateTimeField %s.%s received a naive datetime "
                              "(%s) while time zone support is active." %
                              (self.model.__name__, self.name, value),
                              RuntimeWarning)
                default_timezone = timezone.get_default_timezone()
                value = timezone.make_aware(value, default_timezone)
            return value
    
        try:
>           parsed = parse_datetime(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1367: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <function now at 0x7fc4c29e8d30>

    def parse_datetime(value):
        """Parse a string and return a datetime.datetime.
    
        This function supports time zone offsets. When the input contains one,
        the output uses a timezone with a fixed offset from UTC.
    
        Raise ValueError if the input is well formatted but not a valid datetime.
        Return None if the input isn't well formatted.
        """
>       match = datetime_re.match(value)
E       TypeError: expected string or bytes-like object

venv/lib/python3.9/site-packages/django/utils/dateparse.py:107: TypeError

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x7fc4c111bca0>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)

tests/conftest.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_client = <django.test.client.Client object at 0x7fc4c111bca0>
page_url = '/category/certain-these/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests/conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x7fc4c111bca0>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests/conftest.py:141: AssertionError
---------------------------- Captured stderr setup -----------------------------
Internal Server Error: /category/certain-these/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
Internal Server Error: /category/certain-these/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
------------------------------ Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /category/certain-these/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
____ ERROR at setup of test_category_page_posts_with_unpublished_locations _____

user_client = <django.test.client.Client object at 0x7fc4bfb89070>
page_url = '/category/senior-space-how/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests/conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4bfb89070>
path = '/category/senior-space-how/', data = None, follow = False
secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv/lib/python3.9/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4bfb89070>
path = '/category/senior-space-how/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv/lib/python3.9/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4bfb89070>, method = 'GET'
path = '/category/senior-space-how/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/senior-space-how/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/senior-space-how/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv/lib/python3.9/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4bfb89070>
request = {'PATH_INFO': '/category/senior-space-how/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=dltqgnm9e5cqz5aauhswghxl3e9bboho', 'PATH_INFO': '/category/senior-space-how/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'is_email': False, 'unicode_hint': '', 'frames': [{'exc_c...jango.template.base.Template object at 0x7fc4bfb6eaf0>, <django.template.base.Template object at 0x7fc4bfb6eaf0>, ...]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7fc4c22fbe50>, {'templates': [<django.template.base.Template...irst': False, 'last': True}, 'panel': <debug_toolbar.panels.profiling.ProfilingPanel object at 0x7fc4c090ff70>}, {}]]})
signal_uid = 'template-render-140483008133376'
exception_uid = 'request-exception-140483008133376'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv/lib/python3.9/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4bfb89070>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv/lib/python3.9/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/senior-space-how/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7fc4bfb89160>
request = <WSGIRequest: GET '/category/senior-space-how/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv/lib/python3.9/site-packages/django/core/handlers/base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/senior-space-how/'>
category_slug = 'senior-space-how'

    def category_posts(request, category_slug):
        """View функция для страницы категорий."""
        try:
            category = Category.objects.get(slug=category_slug, is_published=True)
        except Category.DoesNotExist:
            raise Http404(f"Категория '{category_slug}' не найдена")
>       post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')

blogicum/blog/views.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.manager.Manager object at 0x7fc4c1838e50>, args = ()
kwargs = {'category': <Category: Like Style Significant Simply Production Care>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def manager_method(self, *args, **kwargs):
>       return getattr(self.get_queryset(), name)(*args, **kwargs)

venv/lib/python3.9/site-packages/django/db/models/manager.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
args = ()
kwargs = {'category': <Category: Like Style Significant Simply Production Care>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def filter(self, *args, **kwargs):
        """
        Return a new QuerySet instance with the args ANDed to the existing
        set.
        """
        self._not_support_combined_queries('filter')
>       return self._filter_or_exclude(False, args, kwargs)

venv/lib/python3.9/site-packages/django/db/models/query.py:941: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
negate = False, args = ()
kwargs = {'category': <Category: Like Style Significant Simply Production Care>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def _filter_or_exclude(self, negate, args, kwargs):
        if args or kwargs:
            assert not self.query.is_sliced, \
                "Cannot filter a query once a slice has been taken."
    
        clone = self._chain()
        if self._defer_next_filter:
            self._defer_next_filter = False
            clone._deferred_filter = negate, args, kwargs
        else:
>           clone._filter_or_exclude_inplace(negate, args, kwargs)

venv/lib/python3.9/site-packages/django/db/models/query.py:961: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>]>
negate = False, args = ()
kwargs = {'category': <Category: Like Style Significant Simply Production Care>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def _filter_or_exclude_inplace(self, negate, args, kwargs):
        if negate:
            self._query.add_q(~Q(*args, **kwargs))
        else:
>           self._query.add_q(Q(*args, **kwargs))

venv/lib/python3.9/site-packages/django/db/models/query.py:968: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4bfb6ef10>
q_object = <Q: (AND: ('category', <Category: Like Style Significant Simply Production Care>), ('is_published', True), ('pub_date__lt', <function now at 0x7fc4c29e8d30>))>

    def add_q(self, q_object):
        """
        A preprocessor for the internal _add_q(). Responsible for doing final
        join promotion.
        """
        # For join promotion this case is doing an AND for the added q_object
        # and existing conditions. So, any existing inner join forces the join
        # type to remain inner. Existing outer joins can however be demoted.
        # (Consider case where rel_a is LOUTER and rel_a__col=1 is added - if
        # rel_a doesn't produce any rows, then the whole condition must fail.
        # So, demotion is OK.
        existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
>       clause, _ = self._add_q(q_object, self.used_aliases)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4bfb6ef10>
q_object = <Q: (AND: ('category', <Category: Like Style Significant Simply Production Care>), ('is_published', True), ('pub_date__lt', <function now at 0x7fc4c29e8d30>))>
used_aliases = {'blog_post'}, branch_negated = False, current_negated = False
allow_joins = True, split_subq = True, check_filterable = True

    def _add_q(self, q_object, used_aliases, branch_negated=False,
               current_negated=False, allow_joins=True, split_subq=True,
               check_filterable=True):
        """Add a Q-object to the current filter."""
        connector = q_object.connector
        current_negated = current_negated ^ q_object.negated
        branch_negated = branch_negated or q_object.negated
        target_clause = self.where_class(connector=connector,
                                         negated=q_object.negated)
        joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
        for child in q_object.children:
>           child_clause, needed_inner = self.build_filter(
                child, can_reuse=used_aliases, branch_negated=branch_negated,
                current_negated=current_negated, allow_joins=allow_joins,
                split_subq=split_subq, check_filterable=check_filterable,
            )

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1435: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4bfb6ef10>
filter_expr = ('pub_date__lt', <function now at 0x7fc4c29e8d30>)
branch_negated = False, current_negated = False, can_reuse = {'blog_post'}
allow_joins = True, split_subq = True, reuse_with_filtered_relation = False
check_filterable = True

    def build_filter(self, filter_expr, branch_negated=False, current_negated=False,
                     can_reuse=None, allow_joins=True, split_subq=True,
                     reuse_with_filtered_relation=False, check_filterable=True):
        """
        Build a WhereNode for a single filter clause but don't add it
        to this Query. Query.add_q() will then add this filter to the where
        Node.
    
        The 'branch_negated' tells us if the current branch contains any
        negations. This will be used to determine if subqueries are needed.
    
        The 'current_negated' is used to determine if the current filter is
        negated or not and this will be used to determine if IS NULL filtering
        is needed.
    
        The difference between current_negated and branch_negated is that
        branch_negated is set on first negation, but current_negated is
        flipped for each negation.
    
        Note that add_filter will not do any negating itself, that is done
        upper in the code by add_q().
    
        The 'can_reuse' is a set of reusable joins for multijoins.
    
        If 'reuse_with_filtered_relation' is True, then only joins in can_reuse
        will be reused.
    
        The method will create a filter clause that can be added to the current
        query. However, if the filter isn't added to the query then the caller
        is responsible for unreffing the joins used.
        """
        if isinstance(filter_expr, dict):
            raise FieldError("Cannot parse keyword query as dict")
        if isinstance(filter_expr, Q):
            return self._add_q(
                filter_expr,
                branch_negated=branch_negated,
                current_negated=current_negated,
                used_aliases=can_reuse,
                allow_joins=allow_joins,
                split_subq=split_subq,
                check_filterable=check_filterable,
            )
        if hasattr(filter_expr, 'resolve_expression'):
            if not getattr(filter_expr, 'conditional', False):
                raise TypeError('Cannot filter against a non-conditional expression.')
            condition = self.build_lookup(
                ['exact'], filter_expr.resolve_expression(self, allow_joins=allow_joins), True
            )
            clause = self.where_class()
            clause.add(condition, AND)
            return clause, []
        arg, value = filter_expr
        if not arg:
            raise FieldError("Cannot parse keyword query %r" % arg)
        lookups, parts, reffed_expression = self.solve_lookup_type(arg)
    
        if check_filterable:
            self.check_filterable(reffed_expression)
    
        if not allow_joins and len(parts) > 1:
            raise FieldError("Joined field references are not permitted in this query")
    
        pre_joins = self.alias_refcount.copy()
        value = self.resolve_lookup_value(value, can_reuse, allow_joins)
        used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
    
        if check_filterable:
            self.check_filterable(value)
    
        clause = self.where_class()
        if reffed_expression:
            condition = self.build_lookup(lookups, reffed_expression, value)
            clause.add(condition, AND)
            return clause, []
    
        opts = self.get_meta()
        alias = self.get_initial_alias()
        allow_many = not branch_negated or not split_subq
    
        try:
            join_info = self.setup_joins(
                parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
                reuse_with_filtered_relation=reuse_with_filtered_relation,
            )
    
            # Prevent iterator from being consumed by check_related_objects()
            if isinstance(value, Iterator):
                value = list(value)
            self.check_related_objects(join_info.final_field, value, join_info.opts)
    
            # split_exclude() needs to know which joins were generated for the
            # lookup parts
            self._lookup_joins = join_info.joins
        except MultiJoin as e:
            return self.split_exclude(filter_expr, can_reuse, e.names_with_path)
    
        # Update used_joins before trimming since they are reused to determine
        # which joins could be later promoted to INNER.
        used_joins.update(join_info.joins)
        targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
        if can_reuse is not None:
            can_reuse.update(join_list)
    
        if join_info.final_field.is_relation:
            # No support for transforms for relational fields
            num_lookups = len(lookups)
            if num_lookups > 1:
                raise FieldError('Related Field got invalid lookup: {}'.format(lookups[0]))
            if len(targets) == 1:
                col = self._get_col(targets[0], join_info.final_field, alias)
            else:
                col = MultiColSource(alias, targets, join_info.targets, join_info.final_field)
        else:
            col = self._get_col(targets[0], join_info.final_field, alias)
    
>       condition = self.build_lookup(lookups, col, value)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4bfb6ef10>
lookups = ['lt'], lhs = Col(blog_post, blog.Post.pub_date)
rhs = <function now at 0x7fc4c29e8d30>

    def build_lookup(self, lookups, lhs, rhs):
        """
        Try to extract transforms and lookup from given lhs.
    
        The lhs value is something that works like SQLExpression.
        The rhs value is what the lookup is going to compare against.
        The lookups is a list of names to extract using get_lookup()
        and get_transform().
        """
        # __exact is the default lookup if one isn't given.
        *transforms, lookup_name = lookups or ['exact']
        for name in transforms:
            lhs = self.try_transform(lhs, name)
        # First try get_lookup() so that the lookup takes precedence if the lhs
        # supports both transform and lookup for the name.
        lookup_class = lhs.get_lookup(lookup_name)
        if not lookup_class:
            if lhs.field.is_relation:
                raise FieldError('Related Field got invalid lookup: {}'.format(lookup_name))
            # A lookup wasn't found. Try to interpret the name as a transform
            # and do an Exact lookup against it.
            lhs = self.try_transform(lhs, lookup_name)
            lookup_name = 'exact'
            lookup_class = lhs.get_lookup(lookup_name)
            if not lookup_class:
                return
    
>       lookup = lookup_class(lhs, rhs)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1216: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.lookups.LessThan object at 0x7fc4bfb6a0a0>
lhs = Col(blog_post, blog.Post.pub_date), rhs = <function now at 0x7fc4c29e8d30>

    def __init__(self, lhs, rhs):
        self.lhs, self.rhs = lhs, rhs
>       self.rhs = self.get_prep_lookup()

venv/lib/python3.9/site-packages/django/db/models/lookups.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.lookups.LessThan object at 0x7fc4bfb6a0a0>

    def get_prep_lookup(self):
        if hasattr(self.rhs, 'resolve_expression'):
            return self.rhs
        if self.prepare_rhs and hasattr(self.lhs.output_field, 'get_prep_value'):
>           return self.lhs.output_field.get_prep_value(self.rhs)

venv/lib/python3.9/site-packages/django/db/models/lookups.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def get_prep_value(self, value):
>       value = super().get_prep_value(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1406: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def get_prep_value(self, value):
        value = super().get_prep_value(value)
>       return self.to_python(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def to_python(self, value):
        if value is None:
            return value
        if isinstance(value, datetime.datetime):
            return value
        if isinstance(value, datetime.date):
            value = datetime.datetime(value.year, value.month, value.day)
            if settings.USE_TZ:
                # For backwards compatibility, interpret naive datetimes in
                # local time. This won't work during DST change, but we can't
                # do much about it, so we let the exceptions percolate up the
                # call stack.
                warnings.warn("DateTimeField %s.%s received a naive datetime "
                              "(%s) while time zone support is active." %
                              (self.model.__name__, self.name, value),
                              RuntimeWarning)
                default_timezone = timezone.get_default_timezone()
                value = timezone.make_aware(value, default_timezone)
            return value
    
        try:
>           parsed = parse_datetime(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1367: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <function now at 0x7fc4c29e8d30>

    def parse_datetime(value):
        """Parse a string and return a datetime.datetime.
    
        This function supports time zone offsets. When the input contains one,
        the output uses a timezone with a fixed offset from UTC.
    
        Raise ValueError if the input is well formatted but not a valid datetime.
        Return None if the input isn't well formatted.
        """
>       match = datetime_re.match(value)
E       TypeError: expected string or bytes-like object

venv/lib/python3.9/site-packages/django/utils/dateparse.py:107: TypeError

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x7fc4bfb89070>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)

tests/conftest.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_client = <django.test.client.Client object at 0x7fc4bfb89070>
page_url = '/category/senior-space-how/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests/conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x7fc4bfb89070>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests/conftest.py:141: AssertionError
---------------------------- Captured stderr setup -----------------------------
Internal Server Error: /category/senior-space-how/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
Internal Server Error: /category/senior-space-how/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
------------------------------ Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /category/senior-space-how/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
______________ ERROR at setup of test_many_posts_on_category_page ______________

user_client = <django.test.client.Client object at 0x7fc4bf933f70>
page_url = '/category/occur-realize/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests/conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4bf933f70>
path = '/category/occur-realize/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv/lib/python3.9/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4bf933f70>
path = '/category/occur-realize/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv/lib/python3.9/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4bf933f70>, method = 'GET'
path = '/category/occur-realize/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/occur-realize/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/occur-realize/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv/lib/python3.9/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4bf933f70>
request = {'PATH_INFO': '/category/occur-realize/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=7gcnsayqneua7eht8yyhkttiaapitaeo', 'PATH_INFO': '/category/occur-realize/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'is_email': False, 'unicode_hint': '', 'frames': [{'exc_c...jango.template.base.Template object at 0x7fc4bfbcaa90>, <django.template.base.Template object at 0x7fc4bfbcaa90>, ...]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7fc4c22fbe50>, {'templates': [<django.template.base.Template...irst': False, 'last': True}, 'panel': <debug_toolbar.panels.profiling.ProfilingPanel object at 0x7fc4bfbc5df0>}, {}]]})
signal_uid = 'template-render-140483008410112'
exception_uid = 'request-exception-140483008410112'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv/lib/python3.9/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4bf933f70>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv/lib/python3.9/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/occur-realize/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7fc4bf933a90>
request = <WSGIRequest: GET '/category/occur-realize/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv/lib/python3.9/site-packages/django/core/handlers/base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/occur-realize/'>
category_slug = 'occur-realize'

    def category_posts(request, category_slug):
        """View функция для страницы категорий."""
        try:
            category = Category.objects.get(slug=category_slug, is_published=True)
        except Category.DoesNotExist:
            raise Http404(f"Категория '{category_slug}' не найдена")
>       post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')

blogicum/blog/views.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.manager.Manager object at 0x7fc4c1838e50>, args = ()
kwargs = {'category': <Category: Allow Save Amount Professional Certainly Happen>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def manager_method(self, *args, **kwargs):
>       return getattr(self.get_queryset(), name)(*args, **kwargs)

venv/lib/python3.9/site-packages/django/db/models/manager.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>, <Post: ...Post object (6)>, <Post: Post object (7)>, <Post: Post object (8)>, <Post: Post object (9)>, <Post: Post object (10)>]>
args = ()
kwargs = {'category': <Category: Allow Save Amount Professional Certainly Happen>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def filter(self, *args, **kwargs):
        """
        Return a new QuerySet instance with the args ANDed to the existing
        set.
        """
        self._not_support_combined_queries('filter')
>       return self._filter_or_exclude(False, args, kwargs)

venv/lib/python3.9/site-packages/django/db/models/query.py:941: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>, <Post: ...Post object (6)>, <Post: Post object (7)>, <Post: Post object (8)>, <Post: Post object (9)>, <Post: Post object (10)>]>
negate = False, args = ()
kwargs = {'category': <Category: Allow Save Amount Professional Certainly Happen>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def _filter_or_exclude(self, negate, args, kwargs):
        if args or kwargs:
            assert not self.query.is_sliced, \
                "Cannot filter a query once a slice has been taken."
    
        clone = self._chain()
        if self._defer_next_filter:
            self._defer_next_filter = False
            clone._deferred_filter = negate, args, kwargs
        else:
>           clone._filter_or_exclude_inplace(negate, args, kwargs)

venv/lib/python3.9/site-packages/django/db/models/query.py:961: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>, <Post: ...Post object (6)>, <Post: Post object (7)>, <Post: Post object (8)>, <Post: Post object (9)>, <Post: Post object (10)>]>
negate = False, args = ()
kwargs = {'category': <Category: Allow Save Amount Professional Certainly Happen>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def _filter_or_exclude_inplace(self, negate, args, kwargs):
        if negate:
            self._query.add_q(~Q(*args, **kwargs))
        else:
>           self._query.add_q(Q(*args, **kwargs))

venv/lib/python3.9/site-packages/django/db/models/query.py:968: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c06d6490>
q_object = <Q: (AND: ('category', <Category: Allow Save Amount Professional Certainly Happen>), ('is_published', True), ('pub_date__lt', <function now at 0x7fc4c29e8d30>))>

    def add_q(self, q_object):
        """
        A preprocessor for the internal _add_q(). Responsible for doing final
        join promotion.
        """
        # For join promotion this case is doing an AND for the added q_object
        # and existing conditions. So, any existing inner join forces the join
        # type to remain inner. Existing outer joins can however be demoted.
        # (Consider case where rel_a is LOUTER and rel_a__col=1 is added - if
        # rel_a doesn't produce any rows, then the whole condition must fail.
        # So, demotion is OK.
        existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
>       clause, _ = self._add_q(q_object, self.used_aliases)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c06d6490>
q_object = <Q: (AND: ('category', <Category: Allow Save Amount Professional Certainly Happen>), ('is_published', True), ('pub_date__lt', <function now at 0x7fc4c29e8d30>))>
used_aliases = {'blog_post'}, branch_negated = False, current_negated = False
allow_joins = True, split_subq = True, check_filterable = True

    def _add_q(self, q_object, used_aliases, branch_negated=False,
               current_negated=False, allow_joins=True, split_subq=True,
               check_filterable=True):
        """Add a Q-object to the current filter."""
        connector = q_object.connector
        current_negated = current_negated ^ q_object.negated
        branch_negated = branch_negated or q_object.negated
        target_clause = self.where_class(connector=connector,
                                         negated=q_object.negated)
        joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
        for child in q_object.children:
>           child_clause, needed_inner = self.build_filter(
                child, can_reuse=used_aliases, branch_negated=branch_negated,
                current_negated=current_negated, allow_joins=allow_joins,
                split_subq=split_subq, check_filterable=check_filterable,
            )

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1435: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c06d6490>
filter_expr = ('pub_date__lt', <function now at 0x7fc4c29e8d30>)
branch_negated = False, current_negated = False, can_reuse = {'blog_post'}
allow_joins = True, split_subq = True, reuse_with_filtered_relation = False
check_filterable = True

    def build_filter(self, filter_expr, branch_negated=False, current_negated=False,
                     can_reuse=None, allow_joins=True, split_subq=True,
                     reuse_with_filtered_relation=False, check_filterable=True):
        """
        Build a WhereNode for a single filter clause but don't add it
        to this Query. Query.add_q() will then add this filter to the where
        Node.
    
        The 'branch_negated' tells us if the current branch contains any
        negations. This will be used to determine if subqueries are needed.
    
        The 'current_negated' is used to determine if the current filter is
        negated or not and this will be used to determine if IS NULL filtering
        is needed.
    
        The difference between current_negated and branch_negated is that
        branch_negated is set on first negation, but current_negated is
        flipped for each negation.
    
        Note that add_filter will not do any negating itself, that is done
        upper in the code by add_q().
    
        The 'can_reuse' is a set of reusable joins for multijoins.
    
        If 'reuse_with_filtered_relation' is True, then only joins in can_reuse
        will be reused.
    
        The method will create a filter clause that can be added to the current
        query. However, if the filter isn't added to the query then the caller
        is responsible for unreffing the joins used.
        """
        if isinstance(filter_expr, dict):
            raise FieldError("Cannot parse keyword query as dict")
        if isinstance(filter_expr, Q):
            return self._add_q(
                filter_expr,
                branch_negated=branch_negated,
                current_negated=current_negated,
                used_aliases=can_reuse,
                allow_joins=allow_joins,
                split_subq=split_subq,
                check_filterable=check_filterable,
            )
        if hasattr(filter_expr, 'resolve_expression'):
            if not getattr(filter_expr, 'conditional', False):
                raise TypeError('Cannot filter against a non-conditional expression.')
            condition = self.build_lookup(
                ['exact'], filter_expr.resolve_expression(self, allow_joins=allow_joins), True
            )
            clause = self.where_class()
            clause.add(condition, AND)
            return clause, []
        arg, value = filter_expr
        if not arg:
            raise FieldError("Cannot parse keyword query %r" % arg)
        lookups, parts, reffed_expression = self.solve_lookup_type(arg)
    
        if check_filterable:
            self.check_filterable(reffed_expression)
    
        if not allow_joins and len(parts) > 1:
            raise FieldError("Joined field references are not permitted in this query")
    
        pre_joins = self.alias_refcount.copy()
        value = self.resolve_lookup_value(value, can_reuse, allow_joins)
        used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
    
        if check_filterable:
            self.check_filterable(value)
    
        clause = self.where_class()
        if reffed_expression:
            condition = self.build_lookup(lookups, reffed_expression, value)
            clause.add(condition, AND)
            return clause, []
    
        opts = self.get_meta()
        alias = self.get_initial_alias()
        allow_many = not branch_negated or not split_subq
    
        try:
            join_info = self.setup_joins(
                parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
                reuse_with_filtered_relation=reuse_with_filtered_relation,
            )
    
            # Prevent iterator from being consumed by check_related_objects()
            if isinstance(value, Iterator):
                value = list(value)
            self.check_related_objects(join_info.final_field, value, join_info.opts)
    
            # split_exclude() needs to know which joins were generated for the
            # lookup parts
            self._lookup_joins = join_info.joins
        except MultiJoin as e:
            return self.split_exclude(filter_expr, can_reuse, e.names_with_path)
    
        # Update used_joins before trimming since they are reused to determine
        # which joins could be later promoted to INNER.
        used_joins.update(join_info.joins)
        targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
        if can_reuse is not None:
            can_reuse.update(join_list)
    
        if join_info.final_field.is_relation:
            # No support for transforms for relational fields
            num_lookups = len(lookups)
            if num_lookups > 1:
                raise FieldError('Related Field got invalid lookup: {}'.format(lookups[0]))
            if len(targets) == 1:
                col = self._get_col(targets[0], join_info.final_field, alias)
            else:
                col = MultiColSource(alias, targets, join_info.targets, join_info.final_field)
        else:
            col = self._get_col(targets[0], join_info.final_field, alias)
    
>       condition = self.build_lookup(lookups, col, value)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4c06d6490>
lookups = ['lt'], lhs = Col(blog_post, blog.Post.pub_date)
rhs = <function now at 0x7fc4c29e8d30>

    def build_lookup(self, lookups, lhs, rhs):
        """
        Try to extract transforms and lookup from given lhs.
    
        The lhs value is something that works like SQLExpression.
        The rhs value is what the lookup is going to compare against.
        The lookups is a list of names to extract using get_lookup()
        and get_transform().
        """
        # __exact is the default lookup if one isn't given.
        *transforms, lookup_name = lookups or ['exact']
        for name in transforms:
            lhs = self.try_transform(lhs, name)
        # First try get_lookup() so that the lookup takes precedence if the lhs
        # supports both transform and lookup for the name.
        lookup_class = lhs.get_lookup(lookup_name)
        if not lookup_class:
            if lhs.field.is_relation:
                raise FieldError('Related Field got invalid lookup: {}'.format(lookup_name))
            # A lookup wasn't found. Try to interpret the name as a transform
            # and do an Exact lookup against it.
            lhs = self.try_transform(lhs, lookup_name)
            lookup_name = 'exact'
            lookup_class = lhs.get_lookup(lookup_name)
            if not lookup_class:
                return
    
>       lookup = lookup_class(lhs, rhs)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1216: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.lookups.LessThan object at 0x7fc4c06c6400>
lhs = Col(blog_post, blog.Post.pub_date), rhs = <function now at 0x7fc4c29e8d30>

    def __init__(self, lhs, rhs):
        self.lhs, self.rhs = lhs, rhs
>       self.rhs = self.get_prep_lookup()

venv/lib/python3.9/site-packages/django/db/models/lookups.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.lookups.LessThan object at 0x7fc4c06c6400>

    def get_prep_lookup(self):
        if hasattr(self.rhs, 'resolve_expression'):
            return self.rhs
        if self.prepare_rhs and hasattr(self.lhs.output_field, 'get_prep_value'):
>           return self.lhs.output_field.get_prep_value(self.rhs)

venv/lib/python3.9/site-packages/django/db/models/lookups.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def get_prep_value(self, value):
>       value = super().get_prep_value(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1406: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def get_prep_value(self, value):
        value = super().get_prep_value(value)
>       return self.to_python(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def to_python(self, value):
        if value is None:
            return value
        if isinstance(value, datetime.datetime):
            return value
        if isinstance(value, datetime.date):
            value = datetime.datetime(value.year, value.month, value.day)
            if settings.USE_TZ:
                # For backwards compatibility, interpret naive datetimes in
                # local time. This won't work during DST change, but we can't
                # do much about it, so we let the exceptions percolate up the
                # call stack.
                warnings.warn("DateTimeField %s.%s received a naive datetime "
                              "(%s) while time zone support is active." %
                              (self.model.__name__, self.name, value),
                              RuntimeWarning)
                default_timezone = timezone.get_default_timezone()
                value = timezone.make_aware(value, default_timezone)
            return value
    
        try:
>           parsed = parse_datetime(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1367: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <function now at 0x7fc4c29e8d30>

    def parse_datetime(value):
        """Parse a string and return a datetime.datetime.
    
        This function supports time zone offsets. When the input contains one,
        the output uses a timezone with a fixed offset from UTC.
    
        Raise ValueError if the input is well formatted but not a valid datetime.
        Return None if the input isn't well formatted.
        """
>       match = datetime_re.match(value)
E       TypeError: expected string or bytes-like object

venv/lib/python3.9/site-packages/django/utils/dateparse.py:107: TypeError

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x7fc4bf933f70>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)

tests/conftest.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_client = <django.test.client.Client object at 0x7fc4bf933f70>
page_url = '/category/occur-realize/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests/conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x7fc4bf933f70>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests/conftest.py:141: AssertionError
---------------------------- Captured stderr setup -----------------------------
Internal Server Error: /category/occur-realize/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
Internal Server Error: /category/occur-realize/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
------------------------------ Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /category/occur-realize/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
____________ ERROR at setup of test_no_other_posts_on_category_page ____________

user_client = <django.test.client.Client object at 0x7fc4bfaa63d0>
page_url = '/category/hit-common-into/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests/conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4bfaa63d0>
path = '/category/hit-common-into/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv/lib/python3.9/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4bfaa63d0>
path = '/category/hit-common-into/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv/lib/python3.9/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4bfaa63d0>, method = 'GET'
path = '/category/hit-common-into/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/hit-common-into/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/hit-common-into/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv/lib/python3.9/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4bfaa63d0>
request = {'PATH_INFO': '/category/hit-common-into/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=9solxt3xavenvu7dehipesuzlcrwccx4', 'PATH_INFO': '/category/hit-common-into/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'is_email': False, 'unicode_hint': '', 'frames': [{'exc_c...jango.template.base.Template object at 0x7fc4bffaaa30>, <django.template.base.Template object at 0x7fc4bffaaa30>, ...]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7fc4c22fbe50>, {'templates': [<django.template.base.Template...irst': False, 'last': True}, 'panel': <debug_toolbar.panels.profiling.ProfilingPanel object at 0x7fc4bffa5100>}, {}]]})
signal_uid = 'template-render-140483005938688'
exception_uid = 'request-exception-140483005938688'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv/lib/python3.9/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fc4bfaa63d0>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv/lib/python3.9/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/hit-common-into/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7fc4bfaa64c0>
request = <WSGIRequest: GET '/category/hit-common-into/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv/lib/python3.9/site-packages/django/core/handlers/base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/hit-common-into/'>
category_slug = 'hit-common-into'

    def category_posts(request, category_slug):
        """View функция для страницы категорий."""
        try:
            category = Category.objects.get(slug=category_slug, is_published=True)
        except Category.DoesNotExist:
            raise Http404(f"Категория '{category_slug}' не найдена")
>       post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')

blogicum/blog/views.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.manager.Manager object at 0x7fc4c1838e50>, args = ()
kwargs = {'category': <Category: Continue Most Fly Sea Seat Staff>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def manager_method(self, *args, **kwargs):
>       return getattr(self.get_queryset(), name)(*args, **kwargs)

venv/lib/python3.9/site-packages/django/db/models/manager.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>, <Post: ...st object (8)>, <Post: Post object (9)>, <Post: Post object (10)>, <Post: Post object (11)>, <Post: Post object (12)>]>
args = ()
kwargs = {'category': <Category: Continue Most Fly Sea Seat Staff>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def filter(self, *args, **kwargs):
        """
        Return a new QuerySet instance with the args ANDed to the existing
        set.
        """
        self._not_support_combined_queries('filter')
>       return self._filter_or_exclude(False, args, kwargs)

venv/lib/python3.9/site-packages/django/db/models/query.py:941: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>, <Post: ...st object (8)>, <Post: Post object (9)>, <Post: Post object (10)>, <Post: Post object (11)>, <Post: Post object (12)>]>
negate = False, args = ()
kwargs = {'category': <Category: Continue Most Fly Sea Seat Staff>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def _filter_or_exclude(self, negate, args, kwargs):
        if args or kwargs:
            assert not self.query.is_sliced, \
                "Cannot filter a query once a slice has been taken."
    
        clone = self._chain()
        if self._defer_next_filter:
            self._defer_next_filter = False
            clone._deferred_filter = negate, args, kwargs
        else:
>           clone._filter_or_exclude_inplace(negate, args, kwargs)

venv/lib/python3.9/site-packages/django/db/models/query.py:961: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, <Post: Post object (4)>, <Post: ...st object (8)>, <Post: Post object (9)>, <Post: Post object (10)>, <Post: Post object (11)>, <Post: Post object (12)>]>
negate = False, args = ()
kwargs = {'category': <Category: Continue Most Fly Sea Seat Staff>, 'is_published': True, 'pub_date__lt': <function now at 0x7fc4c29e8d30>}

    def _filter_or_exclude_inplace(self, negate, args, kwargs):
        if negate:
            self._query.add_q(~Q(*args, **kwargs))
        else:
>           self._query.add_q(Q(*args, **kwargs))

venv/lib/python3.9/site-packages/django/db/models/query.py:968: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4bf996dc0>
q_object = <Q: (AND: ('category', <Category: Continue Most Fly Sea Seat Staff>), ('is_published', True), ('pub_date__lt', <function now at 0x7fc4c29e8d30>))>

    def add_q(self, q_object):
        """
        A preprocessor for the internal _add_q(). Responsible for doing final
        join promotion.
        """
        # For join promotion this case is doing an AND for the added q_object
        # and existing conditions. So, any existing inner join forces the join
        # type to remain inner. Existing outer joins can however be demoted.
        # (Consider case where rel_a is LOUTER and rel_a__col=1 is added - if
        # rel_a doesn't produce any rows, then the whole condition must fail.
        # So, demotion is OK.
        existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
>       clause, _ = self._add_q(q_object, self.used_aliases)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4bf996dc0>
q_object = <Q: (AND: ('category', <Category: Continue Most Fly Sea Seat Staff>), ('is_published', True), ('pub_date__lt', <function now at 0x7fc4c29e8d30>))>
used_aliases = {'blog_post'}, branch_negated = False, current_negated = False
allow_joins = True, split_subq = True, check_filterable = True

    def _add_q(self, q_object, used_aliases, branch_negated=False,
               current_negated=False, allow_joins=True, split_subq=True,
               check_filterable=True):
        """Add a Q-object to the current filter."""
        connector = q_object.connector
        current_negated = current_negated ^ q_object.negated
        branch_negated = branch_negated or q_object.negated
        target_clause = self.where_class(connector=connector,
                                         negated=q_object.negated)
        joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
        for child in q_object.children:
>           child_clause, needed_inner = self.build_filter(
                child, can_reuse=used_aliases, branch_negated=branch_negated,
                current_negated=current_negated, allow_joins=allow_joins,
                split_subq=split_subq, check_filterable=check_filterable,
            )

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1435: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4bf996dc0>
filter_expr = ('pub_date__lt', <function now at 0x7fc4c29e8d30>)
branch_negated = False, current_negated = False, can_reuse = {'blog_post'}
allow_joins = True, split_subq = True, reuse_with_filtered_relation = False
check_filterable = True

    def build_filter(self, filter_expr, branch_negated=False, current_negated=False,
                     can_reuse=None, allow_joins=True, split_subq=True,
                     reuse_with_filtered_relation=False, check_filterable=True):
        """
        Build a WhereNode for a single filter clause but don't add it
        to this Query. Query.add_q() will then add this filter to the where
        Node.
    
        The 'branch_negated' tells us if the current branch contains any
        negations. This will be used to determine if subqueries are needed.
    
        The 'current_negated' is used to determine if the current filter is
        negated or not and this will be used to determine if IS NULL filtering
        is needed.
    
        The difference between current_negated and branch_negated is that
        branch_negated is set on first negation, but current_negated is
        flipped for each negation.
    
        Note that add_filter will not do any negating itself, that is done
        upper in the code by add_q().
    
        The 'can_reuse' is a set of reusable joins for multijoins.
    
        If 'reuse_with_filtered_relation' is True, then only joins in can_reuse
        will be reused.
    
        The method will create a filter clause that can be added to the current
        query. However, if the filter isn't added to the query then the caller
        is responsible for unreffing the joins used.
        """
        if isinstance(filter_expr, dict):
            raise FieldError("Cannot parse keyword query as dict")
        if isinstance(filter_expr, Q):
            return self._add_q(
                filter_expr,
                branch_negated=branch_negated,
                current_negated=current_negated,
                used_aliases=can_reuse,
                allow_joins=allow_joins,
                split_subq=split_subq,
                check_filterable=check_filterable,
            )
        if hasattr(filter_expr, 'resolve_expression'):
            if not getattr(filter_expr, 'conditional', False):
                raise TypeError('Cannot filter against a non-conditional expression.')
            condition = self.build_lookup(
                ['exact'], filter_expr.resolve_expression(self, allow_joins=allow_joins), True
            )
            clause = self.where_class()
            clause.add(condition, AND)
            return clause, []
        arg, value = filter_expr
        if not arg:
            raise FieldError("Cannot parse keyword query %r" % arg)
        lookups, parts, reffed_expression = self.solve_lookup_type(arg)
    
        if check_filterable:
            self.check_filterable(reffed_expression)
    
        if not allow_joins and len(parts) > 1:
            raise FieldError("Joined field references are not permitted in this query")
    
        pre_joins = self.alias_refcount.copy()
        value = self.resolve_lookup_value(value, can_reuse, allow_joins)
        used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
    
        if check_filterable:
            self.check_filterable(value)
    
        clause = self.where_class()
        if reffed_expression:
            condition = self.build_lookup(lookups, reffed_expression, value)
            clause.add(condition, AND)
            return clause, []
    
        opts = self.get_meta()
        alias = self.get_initial_alias()
        allow_many = not branch_negated or not split_subq
    
        try:
            join_info = self.setup_joins(
                parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
                reuse_with_filtered_relation=reuse_with_filtered_relation,
            )
    
            # Prevent iterator from being consumed by check_related_objects()
            if isinstance(value, Iterator):
                value = list(value)
            self.check_related_objects(join_info.final_field, value, join_info.opts)
    
            # split_exclude() needs to know which joins were generated for the
            # lookup parts
            self._lookup_joins = join_info.joins
        except MultiJoin as e:
            return self.split_exclude(filter_expr, can_reuse, e.names_with_path)
    
        # Update used_joins before trimming since they are reused to determine
        # which joins could be later promoted to INNER.
        used_joins.update(join_info.joins)
        targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
        if can_reuse is not None:
            can_reuse.update(join_list)
    
        if join_info.final_field.is_relation:
            # No support for transforms for relational fields
            num_lookups = len(lookups)
            if num_lookups > 1:
                raise FieldError('Related Field got invalid lookup: {}'.format(lookups[0]))
            if len(targets) == 1:
                col = self._get_col(targets[0], join_info.final_field, alias)
            else:
                col = MultiColSource(alias, targets, join_info.targets, join_info.final_field)
        else:
            col = self._get_col(targets[0], join_info.final_field, alias)
    
>       condition = self.build_lookup(lookups, col, value)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7fc4bf996dc0>
lookups = ['lt'], lhs = Col(blog_post, blog.Post.pub_date)
rhs = <function now at 0x7fc4c29e8d30>

    def build_lookup(self, lookups, lhs, rhs):
        """
        Try to extract transforms and lookup from given lhs.
    
        The lhs value is something that works like SQLExpression.
        The rhs value is what the lookup is going to compare against.
        The lookups is a list of names to extract using get_lookup()
        and get_transform().
        """
        # __exact is the default lookup if one isn't given.
        *transforms, lookup_name = lookups or ['exact']
        for name in transforms:
            lhs = self.try_transform(lhs, name)
        # First try get_lookup() so that the lookup takes precedence if the lhs
        # supports both transform and lookup for the name.
        lookup_class = lhs.get_lookup(lookup_name)
        if not lookup_class:
            if lhs.field.is_relation:
                raise FieldError('Related Field got invalid lookup: {}'.format(lookup_name))
            # A lookup wasn't found. Try to interpret the name as a transform
            # and do an Exact lookup against it.
            lhs = self.try_transform(lhs, lookup_name)
            lookup_name = 'exact'
            lookup_class = lhs.get_lookup(lookup_name)
            if not lookup_class:
                return
    
>       lookup = lookup_class(lhs, rhs)

venv/lib/python3.9/site-packages/django/db/models/sql/query.py:1216: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.lookups.LessThan object at 0x7fc4bf996430>
lhs = Col(blog_post, blog.Post.pub_date), rhs = <function now at 0x7fc4c29e8d30>

    def __init__(self, lhs, rhs):
        self.lhs, self.rhs = lhs, rhs
>       self.rhs = self.get_prep_lookup()

venv/lib/python3.9/site-packages/django/db/models/lookups.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.lookups.LessThan object at 0x7fc4bf996430>

    def get_prep_lookup(self):
        if hasattr(self.rhs, 'resolve_expression'):
            return self.rhs
        if self.prepare_rhs and hasattr(self.lhs.output_field, 'get_prep_value'):
>           return self.lhs.output_field.get_prep_value(self.rhs)

venv/lib/python3.9/site-packages/django/db/models/lookups.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def get_prep_value(self, value):
>       value = super().get_prep_value(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1406: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def get_prep_value(self, value):
        value = super().get_prep_value(value)
>       return self.to_python(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.DateTimeField: pub_date>
value = <function now at 0x7fc4c29e8d30>

    def to_python(self, value):
        if value is None:
            return value
        if isinstance(value, datetime.datetime):
            return value
        if isinstance(value, datetime.date):
            value = datetime.datetime(value.year, value.month, value.day)
            if settings.USE_TZ:
                # For backwards compatibility, interpret naive datetimes in
                # local time. This won't work during DST change, but we can't
                # do much about it, so we let the exceptions percolate up the
                # call stack.
                warnings.warn("DateTimeField %s.%s received a naive datetime "
                              "(%s) while time zone support is active." %
                              (self.model.__name__, self.name, value),
                              RuntimeWarning)
                default_timezone = timezone.get_default_timezone()
                value = timezone.make_aware(value, default_timezone)
            return value
    
        try:
>           parsed = parse_datetime(value)

venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py:1367: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <function now at 0x7fc4c29e8d30>

    def parse_datetime(value):
        """Parse a string and return a datetime.datetime.
    
        This function supports time zone offsets. When the input contains one,
        the output uses a timezone with a fixed offset from UTC.
    
        Raise ValueError if the input is well formatted but not a valid datetime.
        Return None if the input isn't well formatted.
        """
>       match = datetime_re.match(value)
E       TypeError: expected string or bytes-like object

venv/lib/python3.9/site-packages/django/utils/dateparse.py:107: TypeError

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x7fc4bfaa63d0>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)

tests/conftest.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_client = <django.test.client.Client object at 0x7fc4bfaa63d0>
page_url = '/category/hit-common-into/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests/conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x7fc4bfaa63d0>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests/conftest.py:141: AssertionError
---------------------------- Captured stderr setup -----------------------------
Internal Server Error: /category/hit-common-into/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
Internal Server Error: /category/hit-common-into/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
------------------------------ Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /category/hit-common-into/
Traceback (most recent call last):
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/exception.py", line 47, in inner
    response = get_response(request)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/core/handlers/base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/blogicum/blog/views.py", line 76, in category_posts
    post_list = Post.objects.filter(category=category, is_published=True, pub_date__lt=timezone.now).order_by('-created_at')
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 941, in filter
    return self._filter_or_exclude(False, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 961, in _filter_or_exclude
    clone._filter_or_exclude_inplace(negate, args, kwargs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/query.py", line 968, in _filter_or_exclude_inplace
    self._query.add_q(Q(*args, **kwargs))
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1416, in add_q
    clause, _ = self._add_q(q_object, self.used_aliases)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1435, in _add_q
    child_clause, needed_inner = self.build_filter(
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1370, in build_filter
    condition = self.build_lookup(lookups, col, value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/sql/query.py", line 1216, in build_lookup
    lookup = lookup_class(lhs, rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 25, in __init__
    self.rhs = self.get_prep_lookup()
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/lookups.py", line 77, in get_prep_lookup
    return self.lhs.output_field.get_prep_value(self.rhs)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1406, in get_prep_value
    value = super().get_prep_value(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1266, in get_prep_value
    return self.to_python(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/db/models/fields/__init__.py", line 1367, in to_python
    parsed = parse_datetime(value)
  File "/home/nikita/python-yandex_p/django_sprint3/venv/lib/python3.9/site-packages/django/utils/dateparse.py", line 107, in parse_datetime
    match = datetime_re.match(value)
TypeError: expected string or bytes-like object
=========================== short test summary info ============================
ERROR tests/test_category_page_views.py::test_category_page - AssertionError:...
ERROR tests/test_category_page_views.py::test_category_page_check_context_keys[title]
ERROR tests/test_category_page_views.py::test_category_page_check_context_keys[key1]
ERROR tests/test_category_page_views.py::test_category_page_check_context_keys[key2]
ERROR tests/test_category_page_views.py::test_category_page_check_context_keys[key3]
ERROR tests/test_category_page_views.py::test_category_page_category_unpublished
ERROR tests/test_category_page_views.py::test_category_page_posts_unpublished
ERROR tests/test_category_page_views.py::test_category_page_pub_date_later_today
ERROR tests/test_category_page_views.py::test_category_page_posts_with_location
ERROR tests/test_category_page_views.py::test_category_page_posts_with_unpublished_locations
ERROR tests/test_category_page_views.py::test_many_posts_on_category_page - A...
ERROR tests/test_category_page_views.py::test_no_other_posts_on_category_page
======================== 70 passed, 12 errors in 6.16s =========================
